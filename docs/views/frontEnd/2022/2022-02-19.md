---
title: 前端知识总结
date: 2022-02-19
categories: 前端
---

- HTML语义化

在H5中增加了许多语义化标签，例如aside、nav、header、main、section、footer

这些语义化标签优点：
1. 代码结构更加清晰，增加了代码可读性
2. 更好的SEO

---

- script中defer和async的区别

相同点：立即下载，但不阻塞，外部文件引用

区别：

defer: 延迟脚本。在整个页面解析完毕后执行，不阻塞HTML解析，H5规范中要求顺序执行，先于DOMContentLoaded事件，但现实中不保证执行顺序

async: 异步脚本。有可能阻塞HTML解析，一定在load事件前执行，但可能在DOMContentLoaded事件触发之前或之后执行

---

- 从浏览器地址栏输入url到请求返回发生了什么？

URL的组成：协议、主机、端口、路径、查询参数、锚点

1. 域名解析成IP地址（使用DNS服务器）
2. TCP连接（TCP三次握手）

在发送之前，根据请求头的`expires`和`cache-control`判断是否过期（强缓存），如果没有过期，则直接获取缓存

3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文

在返回HTTP报文时分为两种情况：

一：如果请求头的`If-Modified-Since`和`If-None-Match`判断命中了协商缓存，那么会直接从缓存中取，标志是响应码一般为304

二：如果没有命中协商缓存，则后台返回内容

1. 浏览器解析渲染页面
2. 断开连接（TCP四次挥手）

---

- 盒模型

两种：标准盒模型以及IE（替代）盒模型

CSS中box-sizing表现为content-box和border-box。

在标准盒模型中设置width作用于content，实际容器宽度是width + padding + border，而在IE盒模型中设置的宽度就是盒子的实际宽度

---

- CSS选择器和优先级

选择器: id、class、attr(属性)、name(标签名)、*
优先级：!import > style > id > class > attr > name > *

---

- 重排和重绘

重排(reflow)：也叫**回流**，是更新元素的几何属性后重现触发布局的过程

常见的方式：
1. 元素尺寸变化
2. DOM元素添加或删除
3. 元素位置变化
4. 浏览器窗口尺寸变化
5. 元素内容发生变化
6. 当获取元素的尺寸时也会发生重排现象

重绘(repaint)：当知道几何尺寸变化后，浏览器进入图层绘制阶段，渲染出屏幕的实际尺寸

一般发生在元素颜色、透明度等发生改变，不会影响界面布局

合成：直接跳过布局和图层绘制的阶段，在非主线程上执行更新，如CSS的`transform`属性

---

- 对BFC的理解

块级格式化上下文(Block Formatting context)

它是CSS视觉渲染的一部分，用来决定块级盒的布局及浮动相互影响范围的一个区域

触发BFC的方式：
1. position不为relative和static
2. display值为table-cell、table-caption、inline-block、flex
3. overflow的值为auto、scroll或hidden
4. float的值不为none
5. html根元素

影响
1. 清除浮动的影响，避免父元素塌陷
2. 子元素与外部元素不发生margin合并

---

- 实现两栏布局

1. `flex`
2. `grid`
3. `float`

---

- 实现垂直居中的多种实现方式

1. flex布局 `align-items: center;` + `justify-content: center;`
2. postion: absolute布局，`left`、`top`、`margin`
3. postion: absolute布局，`left`、`top`、`transform`
4. grid布局
5. 一行文本 `text-align`、`line-height`

- flex布局问题

flex属性是`flex-grow`、`flex-shrink`、`flex-basis`的缩写

- `flex-grow`：定义项目的放大比例，默认为0，如果存在剩余空间，也不放大
- `flex-shrink`: 定义项目的缩小比例，默认为1，如果空间不足，项目将等比例缩小
- `flex-basis`: 设置单个项目的宽度，功能类似于`width`，默认值为`auto`

- `flex: none`: `0 0 auto`
- `flex: 1`: `1 1 0%`
- `flex: auto`: `1 1 auto`
- `flex: 0`: `0 1 0%`

---

- line-height

1. 百分比： `font-size` * `line-height`
2. 具体数值：`line-height`

- js数据类型

7种简单数据类型：`null`、`undefined`、`boolean`、`string`、`number`、`Symbol`、`BigInt`

其中`BigInt`用于大数计算

复杂数据类型：`object`

- 判断数据类型

1. `typeof`
2. `instanceof`
3. `Object.prototype.toString.call(xxx)`

- 手写深拷贝

```ts
const deepCopy = (data: unknown, map = new Map()) => {
  if (typeof data !== 'object' || data === null) {
    return data
  }

  if (map.has(data)) {
    return map.get(data)
  }

  let value = Array.isArray(data) ? [] : {}
  map.set(data, value)

  for (const key in data) {
    if (data.hasOwnProperty(key)) {
      value[key] = deepCopy(data[key], map)
    }
  }

  return value
}
```

问题
1. `Function`、`Date`没办法深拷贝

- 0.1 + 0.2 !== 0.3

使用了IEEE-754标准，该标准存储为双精度浮点数类型，浮点数64位，第一位表示符号(sign)，0代表正数，1代表负数；接着有11位代表阶码(exponent)；接着52位代表尾数(mantissa)

公式：`(-1)^sign * 2^(exponent) * 1.mantissa`

阶码：Number.parseInt(1111111111111111, 2) - 1023 = 1024

尾数只能存52位，因此在舍弃第53尾数时根据规则为`舍0补1`

`Number.MAX_SAFE_INTEGER = Math.pow(53) - 1`，由于2^53转二进制为`100000000000000000000000000000000000000000000000000000(53个0)`，只保留52个0，2^53 + 1位`100000000000000000000000000000000000000000000000000001`，舍弃末尾的1，变成52位，因此安全整数为`2^53 - 1`

原因：使用了IEEE-754标准，它的尾数最多52位，在0.1转成二进制后会存在循环，超过52位后自动舍弃，0.2同样如此，因此它们在相加的过程中由于位数舍弃，导致相加之后并不等于0.3

如何判断0.1 + 0.2 = 0.3

1. `Number.EPSILON`判断
2. 转成字符串进行相加操作然后判断

- call、apply、bind实现

都是基本实现，没有深究细节

1. call

```ts
Function.prototype.call2 = function(context = globalThis, ...args) {
  if (typeof this !== 'function') {
    throw new Error(`xxx is not a function`)
  }

  context.fn = this;
  let result = context.fn(...args)
  delete context.fn
  return result
}
```

2. apply

```ts
Function.prototype.apply2 = function(context = globalThis, args) {
  if (typeof this !== 'function') {
    throw new Error(`xxx is not a function`)
  }

  context.fn = this;
  let result = context.fn(...args)
  delete context.fn
  return result
}
```

3. bind

```ts
Function.prototype.bind2 = function(context = globalThis, ...bindArgs) {
  if (typeof this !== 'function') {
    throw new Error(`xxx is not a function`)
  }

  const self = this
  return function(...args) {
    return self.apply(context, bindArgs.concat(args))
  }
}

// 更简单
Function.prototype.bind2 = function(context = globalThis, ...bindArgs) {
  if (typeof this !== 'function') {
    throw new Error(`xxx is not a function`)
  }

  return (...args) => {
    return this.apply(context, bindArgs.concat(args))
  }
}
```

- new实现

```ts
function new2(context, ...args) {
  let obj = Object.create(null)
  obj.__proto__ = context.prototype
  const res = context.apply(obj, args)
  return typeof obj === 'object' ? res : obj
}
```

- reduce实现

```ts
Array.prototype.reduce2 = function(fn, target) {
  let start = 0;
  let value = 0;

  // 查看第二个参数是否存在，如果不存在则从第0项开始
  if (typeof target === 'undefined') {
    value = this[0]
    start = 1
  }

  for (let i = start; i < this.length; i++) {
    value = fn(value, this[i], i, this)
  }
  return value
}
```

- 异步

1. 宏任务：DOM渲染后触发
2. 微任务：DOM渲染前触发

- webpack和rollup的区别

模块打包器的基本特征：
找出所有的依赖，然后打包

webpack

1. 代码拆分，可以按需加载
2. 支持第三方导入，图片导入，CSS预处理等
3. Tree shaking需要做额外工作

rollup

1. Rollup不支持模块的热更新
2. 所有代码放在同一个地方，一次性加载，不产生额外代码，无代码拆分
3. 仅支持JS
4. 通过ES6模块来进行tree-shaking（比webpack好）

vite

1. vite最终打包需要依赖rollup
2. 通过浏览器的ES模块处理模块

---

- 模块的区别

CommonJS: 是由Node应用模块组成，`require`、`module.exports`，特征是同步加载，输出是值的拷贝
AMD: `define`、`require`，RequiredJS为代表，特征是依赖前置，提前执行
CMD: `define`、`use`，SeaJS为代表，依赖就近，延迟执行
UMD: 是集结了CommonJS、CMD、AMD规范于一身，通过判断条件来让代码运行相关模块
ES6: `import`、`export default`，特征是编译时输出，输出是值的引用

---

- MVC与MVVM的区别

- lottie的原理

根据JSON文件的相应属性去读取文件的内容，更加相应数据结构渲染出相应动画

---

- webpack相关

功能：模块打包（开发时任意划分文件模块）、编译兼容（polyfill功能）、能力拓展（plugin功能）

打包原理：
1. 读取`webpack`配置参数
2. 启动`webpack`，创建`compiler`对象并开始解析项目
3. 从入口文件(entry)开始解析，找到其导入的依赖模块，递归遍历分析，形成依赖关系树（AST语法树）
4. 对不同类型的依赖模块文件使用对应的`loader`进行编译，最终转为JS文件
5. 过程中webpack对外抛出hooks，plugin通过监听事件节点，达到干预输出结果的目的

compiler: 全局单例，负责打包构建

compilation: 构建的上下文对象，包含构建信息

`__webpack_modules__`: 编译后的JS内容，key-value形式
`__webpack_module_cache`: 模块缓存，缓存后如果命中直接返回
`__webpack_require__`: 依赖引入函数

SourceMap:



Loader功能：负责文件转换

plugin功能：负责功能拓展

## 参考来源

- [做了一份前端面试复习计划，保熟～](https://juejin.cn/post/7061588533214969892)
- [当面试官问Webpack的时候他想知道什么](https://juejin.cn/post/6943468761575849992)
