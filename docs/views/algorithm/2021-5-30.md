---
title: 算法打卡
date: 2021-12-17
categories: 算法
tags:
 - 打卡
 - 算法
---

## 子集 II

[地址](https://leetcode-cn.com/problems/subsets-ii/)

```ts
function subsetsWithDup(nums: number[]): number[][] {
  const result: number[][] = []
  const path = []
  const len = nums.length

  const back = (nums: number[], start: number = 0) => {
    result.push([...path])

    if (start >= len) {
      return
    }

    for (let i = start; i < len; i++) {
      if (i > start && nums[i] === nums[i-1]) {
        continue
      }
      path.push(nums[i])
      back(nums, i + 1)
      path.pop()
    }
  }

  // 注意排序
  back(nums.sort((a, b) => a - b))
  return result
}
```

## 子集

[地址](https://leetcode-cn.com/problems/subsets/)

```ts
function subsets(nums: number[]): number[][] {
  const result: number[][] = []
  const path = []
  const len = nums.length

  const back = (nums: number[], start: number = 0) => {
    result.push([...path])

    if (start >= len) {
      return
    }

    for (let i = start; i < len; i++) {
      path.push(nums[i])
      back(nums, i + 1)
      path.pop()
    }
  }
  back(nums)
  return result
}
```

## 复原 IP 地址

[地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```ts
function restoreIpAddresses(s: string): string[] {
  const len = s.length
  if (len < 4 || len > 12) {
    return []
  }
  const result: string[] = []
  const path: string[] = []

  const back = (s: string, start: number = 0) => {
    if (path.length >= 4) {
      start >= len && result.push(path.join('.'))
      return
    }

    for (let i = start; i < len; i++) {
      let val = s.slice(start, i + 1)

      // 第一个为0
      if (i > start && s[start] === '0') {
        break
      }

      if (i - start > 3 || +val > 255) {
        break
      }
      path.push(val)
      back(s, i + 1)
      path.pop()
    }
  }
  back(s)
  return result
}
```

```ts
function restoreIpAddresses(s: string): string[] {
  const len = s.length
  if (len < 4 || len > 12) {
    return []
  }
  const result: string[] = []
  let str = ''

  const back = (s: string, start: number = 0, dotNum = 0) => {
    // 有四个点了
    if (dotNum >= 4) {

      // 判断后三个字符串长度
      if (start >= len) {
        result.push(str.slice(0, -1));
      }
      return
    }

    for (let i = start, len1 = Math.min(start + 3, len); i < len1; i++) {

      // 如果截取的值大于255
      let value = s.slice(start, i + 1)
      if (+value > 255) {
        return
      }

      str += value + '.'
      back(s, i + 1, ++dotNum)
      dotNum--
      str = str.slice(0, start - i - 2)

      // 如果第一个为'0'
      if (s[start] === '0') {
        return
      }
    }
  }
  back(s, 0, 0)
  return result
}
```

## 分割回文串

[地址](https://leetcode-cn.com/problems/palindrome-partitioning/)

```ts
function partition(s: string): string[][] {
  const result: string[][] = []
  const path: string[] = []
  const len = s.length

  const back = (s: string, start: number = 0) => {
    if (start >= len) {
      result.push([...path])
      return
    }

    for (let i = start; i < len; i++) {
      // 判断是否是回文，然后推入
      let j = i
      let str = ''
      while (j >= start && s[j] === s[i-j+start]) {
        str += s[j--]
      }

      if (j === start - 1) {
        path.push(str)
        back(s, start + str.length)
        path.pop()
      }
    }
  }
  back(s)
  return result
}
```

## 组合总和 II

[地址](https://leetcode-cn.com/problems/combination-sum-ii/)

```ts
function combinationSum2(candidates: number[], target: number): number[][] {
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径
  const len = candidates.length

  const back = (candidates: number[], target: number, start: number = 0) => {

    // 终止条件
    if (target <= 0) {
      if (!target) {
        result.push([...path])
      }
      return
    }

    for (let i = start; i < len; i++) {
      if (i > start && candidates[i] === candidates[i - 1]) {
        continue
      }
      path.push(candidates[i])
      back(candidates, target - candidates[i], i + 1)
      path.pop()
    }
  }

  back(candidates.sort((prev, next) => prev - next), target)

  return result
};
```

## 组合总和

[地址](https://leetcode-cn.com/problems/combination-sum/)

```ts
function combinationSum(candidates: number[], target: number): number[][] {
  const result: number[][] = []
  const path: number[] = []
  const len = candidates.length

  const back = (candidates: number[], target: number, start: number = 0) => {
    if (target <= 0) {
      if (!target) {
        result.push([...path])
      }
      return
    }

    for (let i = start; i < len; i++) {
      path.push(candidates[i])
      back(candidates, target - candidates[i], i)
      path.pop()

    }
  }
  back(candidates, target)
  return result
};
```

优化：

```ts
function combinationSum(candidates: number[], target: number): number[][] {
  const result: number[][] = []
  const path: number[] = []
  const len = candidates.length

  const back = (candidates: number[], target: number, start: number = 0) => {
    if (target <= 0) {
      if (!target) {
        result.push([...path])
      }
      return
    }

    if (candidates[start] > target) {
      return
    }

    for (let i = start; i < len; i++) {
      path.push(candidates[i])
      back(candidates, target - candidates[i], i)
      path.pop()
    }
  }
  back(candidates.sort((prev, next) => prev - next), target)

  return result
}
```

## 电话号码的字母组合

[地址](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```ts
function letterCombinations(digits: string): string[] {
  if (!digits) {
    return []
  }

  const key = {
    2: 'abc',
    3: 'def',
    4: 'ghi',
    5: 'jkl',
    6: 'mno',
    7: 'pqrs',
    8: 'tuv',
    9: 'wxyz'
  }

  const result: string[] = []
  let str = ''
  const len = digits.length
  const back = (digits: string, start: number) => {
    if (start === len) {
      result.push(str)
      return
    }

    for (let i = 0; i < key[digits[start]].length; i++) {
      str += key[digits[start]][i]
      back(digits, start + 1)
      str = str.slice(0, -1)
    }
  }

  back(digits, 0)
  return result
}
```

## 组合总和 III

[地址](https://leetcode-cn.com/problems/combination-sum-iii/)

```ts
// 优化
function combinationSum3(k: number, n: number): number[][] {
  if (n > 45) {
    return []
  }
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径
  const minSize = Math.min(10, n)
  const back = (n: number, k: number, start: number) => {
    if (n < start) {
      return
    }

    // 终止条件
    if (path.length === k - 1) {
      if (n < 10) { result.push([...path, n]) }
      return
    }

    for (let i = start; i < minSize; i++) {
      path.push(i)
      back(n - i, k, i + 1)
      path.pop()
    }
  }
  back(n, k, 1)

  return result
}
```

```ts
function combinationSum3(k: number, n: number): number[][] {
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径
  const back = (n: number, k: number, start: number) => {
    if (n < 0) {
      return
    }

    // 终止条件
    if (path.length === k) {
      if (!n) {
        result.push([...path])
      }
      return
    }

    for (let i = start; i < 10; i++) {
      path.push(i)
      back(n - i, k, i + 1)
      path.pop()
    }
  }
  back(n, k, 1)
  return result
}
```

```ts
function combinationSum3(k: number, n: number): number[][] {
  if (n > 45) {
    return []
  }
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径

  const back = (n: number, k: number, left: number) => {

    if (left >= n) {
      return
    }

    // 终止条件
    if (path.length === k - 1 && n < 10) {
      result.push([...path, n])
      return
    }

    while (left < n && left < 10) {
      path.push(++left)
      back(n - left, k, left)
      path.pop()
    }
  }
  back(n, k, 0)
  return result
};
```

## 组合

[地址](https://leetcode-cn.com/problems/combinations/)

```ts
// 优化
function combine(n: number, k: number): number[][] {
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径

  const back = (n: number, k: number, start: number) => {

    // 终止条件
    if (path.length === k) {
      result.push([...path])
      return
    }

    for (let i = start; i <= n - (k - path.length) + 1; i++) {
      path.push(i);
      back(n, k, i + 1)
      path.pop()
    }
  }
  back(n, k, 1)
  return result
}
```

```ts
function combine(n: number, k: number): number[][] {
  const result: number[][] = [] // 存放结果
  const path: number[] = [] // 存放单一路径

  const back = (n: number, k: number, start: number) => {

    // 终止条件
    if (path.length === k) {
      result.push([...path])
      return
    }

    for (let i = start; i <= n; i++) {
      path.push(i);
      back(n, k, i + 1)
      path.pop()
    }
  }
  back(n, k, 1)
  return result
}
```

回溯开始

递归结束

## 把二叉搜索树转换为累加树

[地址](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

```ts
// 右中左
function convertBST(root: TreeNode | null): TreeNode | null {
  if (!root) {
    return null
  }

  let pre = 0
  const cascader = (root) => {
    if (!root) {
      return
    }

    cascader(root.right) // 右
    root.val += pre
    pre = root.val
    cascader(root.left)
  }

  cascader(root)
  return root
};
```

## 将有序数组转换为二叉搜索树

[地址](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)


1. 直接递归

```ts
function sortedArrayToBST(nums: number[]): TreeNode | null {
  const halfLen = Math.floor(nums.length / 2)
  const root = new TreeNode(nums[halfLen])
  if (halfLen > 0) {
    root.left = sortedArrayToBST(nums.slice(0, halfLen))
  }

  if (halfLen < nums.length - 1) {
    root.right = sortedArrayToBST(nums.slice(halfLen + 1, nums.length))
  }

  return root
};
```

2. 使用取值的方式

```ts
function sortedArrayToBST(nums: number[]): TreeNode | null {
  const cascader = (nums: number[], start = 0, end) => {
    if (start >= end) {
      return null
    }
    const halfLen = Math.floor((end + start) / 2)
    const root = new TreeNode(nums[halfLen])
    root.left = cascader(nums, start, halfLen)
    root.right = cascader(nums, halfLen + 1, end)
    return root
  }

  return cascader(nums, 0, nums.length)
};
```

## 修剪二叉搜索树

[地址](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```ts
function trimBST(root: TreeNode | null, low: number, high: number): TreeNode | null {
  if (!root) {
    return null
  }

  // 如果当前值小于最小值
  if (root.val < low) {
    return trimBST(root.right, low, high)
  }

  // 如果当前值大于最大值
  if (root.val > high) {
    return trimBST(root.left, low, high)
  }

  if (root.left) {
    root.left = trimBST(root.left, low, high)
  }

  if (root.right) {
    root.right = trimBST(root.right, low, high)
  }
  return root
}
```

## 删除二叉搜索树中的节点

[地址](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```ts
function deleteNode(root: TreeNode | null, key: number): TreeNode | null {
  // 如果没有找到相关的节点，则直接返回null
  if (!root) {
    return null
  }

  if (root.val === key) {
    // 左树和右树都不存在
    if (!root.left && !root.right) {
      return null
    }

    // 左树存在，右树不存在
    if (root.left && !root.right) {
      return root.left
    }

    // 左树不存在右树存在
    if (root.right && !root.left) {
      return root.right
    }

    // 左树和右树都存在
    let cur = root.right
    while (cur?.left) {
      cur = cur.left
    }
    cur.left = root.left
    return root.right
  }

  // 查看遍历左树还是右树
  if (root.val > key) {
    root.left = deleteNode(root.left, key)
  }

  if (root.val < key) {
    root.right = deleteNode(root.right, key)
  }

  return root
}
```

```ts
function deleteNode(root: TreeNode | null, key: number): TreeNode | null {
  if (!root) {
    return null
  }

  const insertKey = (root: TreeNode | null, insertEle: TreeNode | null) => {
    if (!insertEle) {
      return root
    }
    if (!root) {
      return insertKey
    }
    while (root) {
      if (root.val > insertEle.val) {
        if (root.left) {
          root = root.left
          continue
        }
        root.left = insertEle
        return root
      }
      if (root.right) {
        root = root.right
        continue
      }
      root.right = insertEle
      return root
    }
  }

  if (root.val === key) {
     insertKey(root.right, root.left)
    return root.right ? root.right : root.left
  }

  // 核心思想就是左树移到右树上
  let treeNode = root
  while(root) {
    if (root.left?.val === key) {
      insertKey(root.left.right, root.left.left)
      root.left = root.left.right || root.left.left
      break
    }
    if (root.right?.val === key) {
      insertKey(root.right.right, root.right.left)
      root.right = root.right.right || root.right.left
      break
    }
    root = root.val > key ? root.left : root.right
  }
  return treeNode
}
```

## 二叉搜索树中的插入操作

[地址](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```ts
function insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {
  // 插入到子元素中
  if (!root) {
    return new TreeNode(val)
  }
  const newNode = root
  let cur = newNode
  while (cur) {
    // 查看是向左插入还是向右插入
    if (cur.val > val) {
      if (cur.right) {
        cur = cur.right
        continue
      }
      cur.left = new TreeNode(val)
      return newNode
    }
    if (cur.left) {
      cur = cur.left
      continue
    }
    cur.right = new TreeNode(val)
    return newNode
  }
}
```
## 二叉搜索树的最近公共祖先

[地址](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

可以通过判断左右元素值来得到最近公共祖先

```ts
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  if (!root) {
    return null
  }

  if (!q) {
    return p
  }

  if (!p) {
    return q
  }

  while(root) {

    // 都大于
    if (root.val > p.val && root.val > q.val) {
      root = root.left
      continue
    }

    // 都小于
    if (root.val < p.val && root.val < q.val) {
      root = root.right
      continue
    }
    return root
  }
}
```

## 二叉树的最近公共祖先

[地址](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```ts
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  if (root === p || root === q || !root) {
    return root
  }

  const left = lowestCommonAncestor(root.left, p, q)
  const right = lowestCommonAncestor(root.right, p, q)
  if (left && right) {
    return root
  }

  if (!left && right) {
    return right
  }

  return left
};
```

```ts
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  let curP = p
  let curQ = q
	// 采用后序遍历
  const cascader = (root: TreeNode | null) => {
    if (!root) {
      return null;
    }

    cascader(root.left);
    cascader(root.right);

    // 查找左和右是否相等
    if (curP === curQ) {
      return;
    }

    if (root.left === curP || root.right === curP) {
      curP = root
    }
    if (root.left === curQ || root.right === curQ) {
      curQ = root
    }
  }
  cascader(root)
  return curP;
};
```

## 二叉搜索树中的众数
[地址](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```ts
function findMode(root: TreeNode | null): number[] {
  let maxCount = 0 // 最大频率
  let count = 1 // 统计频率
  let pre: TreeNode | null = null
  let result: number[] = []
  const searchBST = (cur: TreeNode | null) => {
    if (!cur) {
      return
    }

    searchBST(cur.left) // 左
    // 中
    if (!pre) {
      count = 1
    } else if (pre.val === cur.val) {
      count++
    } else {
      count = 1
    }
    pre = cur

    if (count === maxCount) {
      result.push(pre.val)
    } else if (count > maxCount) {
      result = [pre.val]
      maxCount = count
    }
    searchBST(cur.right) // 右
  }
  searchBST(root)
  return result
};
```

```ts
function findMode(root: TreeNode | null): number[] {
  const map = new Map<number, number>();
  let cascader = (root: TreeNode | null) => {
    if (!root) {
      return;
    }
    cascader(root.left);
    map.set(root.val, (map.get(root.val) || 0) + 1);
    cascader(root.right);
  }
  cascader(root);
  let maxTimes = 0;
  let value: number[] = [];
  for (let [key, val] of map.entries()) {
    if (val > maxTimes) {
      value = [key];
      maxTimes = val;
      continue;
    }

    if (val === maxTimes) {
      value.push(key);
    }
  }
  return value;
};
```

## 二叉搜索树的最小绝对差

[地址](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```ts
function getMinimumDifference(root: TreeNode | null): number {
  if (!root) {
    return 0
  }
  const arr: number[] = []
  let minVal = Number.MAX_SAFE_INTEGER
  // 中序遍历
  const cascader = (root: TreeNode | null) => {
    if (!root) {
      return;
    }
    cascader(root.left)
    arr.push(root.val)
    cascader(root.right)
  }
  cascader(root)
  for (let i = 1; i < arr.length; i++) {
    minVal = Math.min(arr[i] - arr[i-1], minVal)
  }
  return minVal
};
```

## 验证二叉搜索树

[地址](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```ts
function isValidBST(root: TreeNode | null): boolean {
  const arr: number[] = [];
  // 中序遍历
  const cascader = (root: TreeNode | null) => {
    if (!root) {
      return;
    }
    cascader(root.left);
    arr.push(root.val);
    cascader(root.right);
  }
  cascader(root);
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] <= arr[i-1]) {
      return false;
    }
  }
  return true;
};
```

## 二叉搜索树中的搜索

[地址](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```ts
function searchBST(root: TreeNode | null, val: number): TreeNode | null {
  // 终止条件
  if (!root) {
    return null;
  }

  if (root.val === val) {
    return root;
  }
	// 二叉搜索树左树小于根节点，右树大于根节点
  return searchBST(root.val > val ? root.left : root.right, val);
};
```

```ts
function searchBST(root: TreeNode | null, val: number): TreeNode | null {
  while(root) {
    if (root.val === val) {
      return root;
    }
    root = root.val > val ? root.left : root.right;
  }
  return null;
};
```

## 合并二叉树

[地址](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```ts
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
  // 终止条件
  if (!root1) {
    return root2;
  }

  if (!root2) {
    return root1;
  }

	// 赋值
  root1.val += root2.val;

	// 递归
  root1.left = mergeTrees(root1.left, root2.left);
  root1.right = mergeTrees(root1.right, root2.right);

  return root1;
};
```

## 最大二叉树

[地址](https://leetcode-cn.com/problems/maximum-binary-tree/)

```ts
function constructMaximumBinaryTree(nums: number[]): TreeNode | null {
  // 如果数组的大小为空，则为空节点
  if (!nums.length) {
    return null
  }

  // 找到最大的元素以及序号
  let maxArr = [nums[0], 0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] > maxArr[0]) {
      maxArr = [nums[i], i]
    }
  }
  const root = new TreeNode(maxArr[0])

  // 左树递归
  root.left = constructMaximumBinaryTree(nums.slice(0, maxArr[1]))

  // 右树递归
  root.right = constructMaximumBinaryTree(nums.slice(maxArr[1] + 1, nums.length))
  return root
};
```

不切割数组的形式

```ts
function constructMaximumBinaryTree(nums: number[]): TreeNode | null {
  const cascader = (nums: number[], left: number, right: number) => {
    // 如果数组的大小为空，则为空节点
    if (left >= right) {
      return null
    }

    // 找到最大的元素的序号
    let maxIdx = left
    for (let i = left + 1; i < right; i++) {
      if (nums[i] > nums[maxIdx]) {
        maxIdx = i
      }
    }

    const root = new TreeNode(nums[maxIdx])
    root.left = cascader(nums, left, maxIdx)
    root.right = cascader(nums, maxIdx + 1, right)

    return root
  }

  return cascader(nums, 0, nums.length)
}
```

## 从前序与中序遍历序列构造二叉树

[地址](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

思路：以前序数组的第一个元素为切割点，大概思路与中序与后序遍历序列构造二叉树一致

```ts
function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
  if (!preorder.length) {
    return null
  }

  const rootValue = preorder[0]
  const root = new TreeNode(rootValue)

  if (preorder.length === 1) {
    return root
  }

  const cutNum = inorder.findIndex(num => num === rootValue)
  root.left = buildTree(preorder.slice(1, cutNum + 1), inorder.slice(0, cutNum))
  root.right = buildTree(preorder.slice(cutNum + 1, preorder.length), inorder.slice(cutNum + 1, inorder.length))
  return root
}
```

## 从中序与后序遍历序列构造二叉树

[地址](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路：以后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，再切割后序数组，后序数组的左数组和中序数组的左数组一致

```ts
function buildTree(inorder: number[], postorder: number[]): TreeNode | null {
  // 如果数组大小为空，则为空节点
  if (!postorder.length) {
    return null
  }

  // 不为空，取后序数组最后一个元素
  const rootValue = postorder[postorder.length - 1]
  const root = new TreeNode(rootValue)

  // 只有一个元素
  if (postorder.length === 1) {
    return root
  }

  // 找到切割点
  const cutNum = inorder.findIndex(num => num === rootValue)

  // 后序数组的左数组长度和中序左数组长度一致

  // 切割中序数组，得到中序左数组和后序左数组
  root.left = buildTree(inorder.slice(0, cutNum), postorder.slice(0, cutNum))

  // 切割后序数组，得到中序右数组和后序右数组
  root.right = buildTree(inorder.slice(cutNum + 1, inorder.length), postorder.slice(cutNum, -1))

  return root;
};
```

## 路径总和 II

[地址](https://leetcode-cn.com/problems/path-sum-ii/)

```ts
function pathSum(root: TreeNode | null, targetSum: number): number[][] {
    let paths: number[][] = [];

    let cascader = (root: TreeNode | null, targetSum, path = []) => {
        if (!root) {
            return;
        }

        // 终止条件，但处于叶子节点时，那么判断是否需要推到paths下
        if (!root.left && !root.right) {
            targetSum === root.val && (paths.push(path.concat(root.val)));
            return;
        }

        // 左孩子
        cascader(root.left, targetSum - root.val, [].concat(...path, root.val));

        // 右孩子
        cascader(root.right, targetSum - root.val, [].concat(...path, root.val));
    }

    cascader(root, targetSum);
    return paths;
};
```

## 路径总和

[地址](https://leetcode-cn.com/problems/path-sum/)

```ts
function hasPathSum(root: TreeNode | null, targetSum: number): boolean {
    if (!root) {
        return false;
    }

    // 终止条件，当没有叶子节点时，查看目标值是否等于叶子节点值
    if (!root.left && !root.right) {
        return targetSum === root.val;
    }

    let left = false;
    let right = false;

    // 查看左边叶子节点是否满足需求
    if (root.left) {
        left = hasPathSum(root.left, targetSum - root.val);
    }

    // 查看右边叶子节点是否满足需求
    if (root.right) {
        right = hasPathSum(root.right, targetSum - root.val);
    }

    return left || right;
};

// 优化
function hasPathSum(root: TreeNode | null, targetSum: number): boolean {
    if (!root) {
        return false;
    }

    // 终止条件，当没有叶子节点时，查看目标值是否等于叶子节点值
    if (!root.left && !root.right) {
        return targetSum === root.val;
    }

    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
};
```

## 找树左下角的值

[地址](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

通过自定义depth，然后迭代解决

```ts
interface NodeAndDepth {
    depth: number;
    root: TreeNode;
}

function findBottomLeftValue(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    let nodeAndDepth: NodeAndDepth[] = [{ depth: 0, root }];
    let val = 0;
    let maxDepth = -1;
    while(nodeAndDepth.length) {
        let node = nodeAndDepth.shift();
        if (!node.root.left && !node.root.right) {
            if (node.depth > maxDepth) {
                val = node.root.val;
                maxDepth = node.depth;
            }
        }
        node.root.left && nodeAndDepth.push({ depth: node.depth + 1, root: node.root.left });
        node.root.right && nodeAndDepth.push({ depth: node.depth + 1, root: node.root.right });
    }
    return val;
};
```

直接迭代解决

```ts
function findBottomLeftValue(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    let nodes: TreeNode[] = [root];
    let val = 0;
    while(nodes.length) {
        let len = nodes.length;
        for (let i = 0; i < len; i++) {
            let node = nodes.shift();
            i === 0 && (val = node.val);
            node.left && nodes.push(node.left);
            node.right && nodes.push(node.right);
        }
    }
    return val;
};
```

## 左叶子之和

[地址](https://leetcode-cn.com/problems/sum-of-left-leaves/)

左叶子概念：该节点有左节点，同时该左节点没有左右节点，则该节点为左叶子

### 递归

```ts
function sumOfLeftLeaves(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    let leftNum = sumOfLeftLeaves(root.left);
    let rightNum = sumOfLeftLeaves(root.right);
    let value = 0;
    if (root.left && !root.left.left && !root.left.right) {
        value = root.left.val;
    }

    return leftNum + rightNum + value;
};
```
### 迭代法

```ts
function sumOfLeftLeaves(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    const nodes: TreeNode[] = [root];
    let sum = 0;
    while(nodes.length) {
        let node = nodes.shift();
        if (node.left && !node.left.left && !node.left.right) {
            sum += node.left.val;
        }
        node.left && nodes.push(node.left);
        node.right && nodes.push(node.right);
    }

    return sum;
};
```

## 二叉树的所有路径

[地址](https://leetcode-cn.com/problems/binary-tree-paths/)
```ts
function binaryTreePaths(root: TreeNode | null): string[] {
    let result: string[] = [];
    let getPath = (root: TreeNode | null, path: string, result: string[] = []) => {
        if (!root) {
            return result;
        }
        path += `${root.val}`;
        if (!root.left && !root.right) {
            return result.push(path);
        }
        root.left && getPath(root.left, path + '->', result);
        root.right && getPath(root.right, path + '->', result);
    }
    getPath(root, '', result)
    return result;
};
```

## 平衡二叉树

[地址](https://leetcode-cn.com/problems/balanced-binary-tree/)

```ts
function isBalanced(root: TreeNode | null): boolean {
    let getDepth = (root: TreeNode | null) => {
        if (!root) {
            return 0;
        }

        // 左树高度
        let leftDepth = getDepth(root.left);
        if (leftDepth === -1) {
            return -1;
        }

        // 右树高度
        let rightDepth = getDepth(root.right);
        if (rightDepth === -1) {
            return -1;
        }

        // 如果高度差大于1则直接返回-1
        return Math.abs(leftDepth - rightDepth) > 1 ? -1 : 1 + Math.max(leftDepth, rightDepth);
    }

    return getDepth(root) !== -1;
};
```

## 完全二叉树的节点个数

[地址](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

### 递归 + 树结构特征

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    let leftDepth = 0;
    let rightDepth = 0;
    let left = root;
    let right = root;

    while(left) {
        left = left.left;
        leftDepth++;
    }

    while (right) {
        right = right.right;
        rightDepth++;
    }

    // 等比数列公式 Sn = a0 * (1 - q^n) / (1 - q)
    // 这里的目的是求取完全二叉树时获得的节点数
    leftDepth
    if (leftDepth === rightDepth) {
        return 2 ** leftDepth - 1;
    }
    return 1 + countNodes(root.right) + countNodes(root.left);
};
```

### 递归

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    if (!root.left && !root.right) {

        // root节点加1
        return 1;
    }

    if (!root.left) {
        return 1 + countNodes(root.right);
    }

    if (!root.right) {
        return 1 + countNodes(root.left);
    }

    return 1 + countNodes(root.right) + countNodes(root.left);
};

function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    return 1 + countNodes(root.right) + countNodes(root.left);
};
```

### 迭代

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    let count = 0;
    let stack: TreeNode[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        count += len;
    }
    return count;
};
```

## 二叉树的最小深度

[地址](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

### 迭代

```ts
function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    let stack: TreeNode[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();

            if (node.left === null || node.right === null) {
                return depth + 1;
            }

            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        depth++;
    }
    return depth;
};
```

### 递归

```ts
function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    const cascader = (root: TreeNode | null, depth = 0) => {
        if (!root.left && !root.right) {
            return depth;
        }

        // 如果左树为null，那么需要计算右树的
        if (!root.left) {
            return cascader(root.right, depth + 1);
        }

        // 如果右树为null，那么计算左树的
        if (!root.right) {
            return cascader(root.left, depth + 1);
        }

        let leftDepth = cascader(root.left, depth + 1);
        let rightDepth = cascader(root.right, depth + 1);
        return Math.min(leftDepth, rightDepth);
    }
    return cascader(root, 0) + 1;
};


function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    if (!root.left && !root.right) {
        return 1;
    }

    if (!root.left) {
        return 1 + minDepth(root.right);
    }

    if (!root.right) {
        return 1 + minDepth(root.left);
    }

    return 1 + Math.min(minDepth(root.right), minDepth(root.left));
};
```

## N 叉树的最大深度

[地址](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

### 递归

```ts
function maxDepth(root: Node | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    if (root.children?.length > 0) {
        for (let i = 0; i < root.children.length; i++) {
            depth = Math.max(maxDepth(root.children[i]), depth);
        }
    }
    return 1 + depth;
};
```

### 迭代

```ts
function maxDepth(root: Node | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    let stack: Node[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            if (node.children?.length > 0) {
                stack.push(...node.children);
            }
        }
        depth++;
    }
    return depth;
};
```

## 二叉树的最大深度

[地址](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

### 迭代

```ts
function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    let stack: TreeNode[] = [root];
    let depth = 0;
    while(stack.length) {
        let size = stack.length;
        for (let i = 0; i < size; i++) {
            let node = stack.shift();
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        depth++;
    }
    return depth;
};
```

### 递归

```ts
function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    let cascaderTree = (root: TreeNode | null, depth = 0) => {
        if (root === null) {
            return depth;
        }
        let leftDepth = cascaderTree(root.left, depth + 1);
        let rightDepth = cascaderTree(root.right, depth + 1);
        return Math.max(leftDepth, rightDepth);
    }
    return cascaderTree(root);
};

function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```
## 对称二叉树

[地址](https://leetcode-cn.com/problems/symmetric-tree/)

### 迭代

```ts
// 迭代1
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    let stack: TreeNode[] = [root.left, root.right];
    while (stack.length) {
        let len = stack.length;
        let curNum: number[] = [];
        for (let i = 0, halfLen = len / 2; i < len; i++) {
            let node = stack.shift();

            // 前一半取值后一半去值
            if (i < halfLen) {
                curNum.push(node?.val);
            } else {
                if (curNum.pop() !== node?.val) {
                    return false;
                }
            }

            node && stack.push(node.left);
            node && stack.push(node.right);
        }
    }

    return true;
};

// 迭代2
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    let queue: TreeNode[] = [root.left, root.right];
    while(queue.length) {
        let leftNode = queue.shift();
        let rightNode = queue.shift();

        // 都为null的情况
        if (!leftNode && !rightNode) {
            continue;
        }

        if (!leftNode && rightNode || (leftNode && !rightNode) || (leftNode.val !== rightNode.val)) {
            return false;
        }

        queue.push(leftNode.left);
        queue.push(rightNode.right);
        queue.push(leftNode.right);
        queue.push(rightNode.left);
    }
    return true;
};
```

### 递归

```ts
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    const compare = (left: TreeNode | null, right: TreeNode | null) => {
        if (!left && right) {
            return false;
        } else if (!right && left) {
            return false;
        } else if (!left && !right) {
            return true;
        } else if (left.val !== right.val) {
            return false;
        }

        // 比较外侧是否对称
        const outside = compare(left.left, right.right);
        // 比较内侧是否对称
        const inside = compare(left.right, right.left);

        return outside && inside;
    }
    return compare(root.left, root.right);
};
```
## 翻转二叉树

### 层序遍历

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift()!;

            // 每层都反转
            let temp = node.left;
            node.left = node.right;
            node.right = temp;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
    }
    return root;
};
```

### 递归

```ts
// 递归遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    if (root === null) {
        return root;
    }

    let temp = root.left;
    root.left = root.right;
    root.right = temp;
    invertTree(root.left);
    invertTree(root.right);
    return root;
};
```

### 迭代

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    if (root === null) {
        return root;
    }

    let stack: TreeNode[] = [root];

    while(stack.length) {
        let node = stack.pop();
        let temp = node.left;
        node.left = node.right;
        node.right = temp;
        node.left && stack.push(node.left);
        node.right && stack.push(node.right);
    }
    return root;
};
```
## 填充每个节点的下一个右侧节点指针 II

[地址](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

代码与1一致

## 填充每个节点的下一个右侧节点指针

[地址](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```ts
function connect(root: Node1 | null): Node1 | null {
    let stack: Node1[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let curNode = null;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            curNode && (curNode.next = node);
            curNode = node;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        curNode.next = null;
    }

    return root;
};
```

## 在每个树行中找最大值

[地址](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```ts
function largestValues(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let max = -Infinity;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            max = Math.max(max, node.val);
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        result.push(max);
    }
    return result;
};
```

## N 叉树的层序遍历

[地址](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```ts
function levelOrder(root: Node | null): number[][] {
    let result: number[][] = [];
    let stack: Node[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let curStack = [];
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            curStack.push(node.val);
            node.children && stack.push(...node.children);
        }
        result.push(curStack);
    }
    return result;
};
```

## 二叉树的层平均值

[地址](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```ts
function averageOfLevels(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let sum = 0;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            sum += node.val;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        result.push(sum / len);
    }
    return result;
};
```

## 二叉树的右视图

[地址](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```ts
function rightSideView(root: TreeNode | null): number[] {
    let result: number[] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.push(curLevel.pop()); // 取最后一个
    }
    return result;
}

// 优化
function rightSideView(root: TreeNode | null): number[] {
    let result: number[] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            if (i === len - 1) {
                result.push(node.val);
            }
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
    }
    return result;
}
```

## 二叉树的层序遍历2

[地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```ts
function levelOrderBottom(root: TreeNode | null): number[][] {
    let result: number[][] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.unshift(curLevel);
    }
    return result;
}
```

## 二叉树的层序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let result: number[][] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.push(curLevel);
    }
    return result;
}
```

## 二叉树的后序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```ts
function postorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [root];
    let cur = null;

    // 顺序中右左
    while (stack.length) {
        cur = stack.pop();
        arr.push(cur.val);
        cur.left && (stack.push(cur.left)); // 左子树后出栈
        cur.right && (stack.push(cur.right)); // 右子树先出栈
    }

    return arr.reverse();
};
```

### 标记法

```ts
function postorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            node.right && stack.push(node.right);
            node.left && stack.push(node.left);
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 二叉树的中序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 迭代法

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [];
    let cur = root;
    while (cur !== null || stack.length) {
       // 先一直到左边
        if (cur !== null) {
            stack.push(cur);
            cur = cur.left;
            continue;
        }

        cur = stack.pop(); // 出栈
        arr.push(cur.val);
        cur = cur.right; // 出栈的元素是否有右子树
    }

    return arr;
};
```

### 标记法

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            node.right && stack.push(node.right);
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            node.left && stack.push(node.left);
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 二叉树的前序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 递归

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    let arr: number[] = [];
    let cascader = (tree: TreeNode) => {
        if (tree === null) {
            return;
        }
        arr.push(tree.val); // 中
        cascader(tree.left); // 左
        cascader(tree.right); // 右
    }
    cascader(root);
    return arr;
};
```

### 迭代法

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [root];
    let cur = null;
    while (stack.length) {
        cur = stack.pop(); // 中间最先出栈，之后左子树，之后右子树
        arr.push(cur.val);
        cur.right && (stack.push(cur.right)); // 右子树后出栈
        cur.left && (stack.push(cur.left)); // 左子树先出栈
    }

    return arr;
};
```

### 标记法

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            node.right && stack.push(node.right);
            node.left && stack.push(node.left);
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 前 K 个高频元素

[地址](https://leetcode-cn.com/problems/top-k-frequent-elements/)

### 解法二

```ts
function topKFrequent(nums: number[], k: number): number[] {
    let map = new Map();

    // 计算出现的频率
    for (const num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
    }
    console.log(Array.from(map.entries()));

    let arr: [number, number][] = Array.from(map.entries()).sort((prev, next) => next[1] - prev[1]);
    let newArr: number[] = [];
    for (let i = 0; i < k; i++) {
        newArr.push(arr[i][0]);
    }

    return newArr;
};
```

### 解法一

```ts
function topKFrequent(nums: number[], k: number): number[] {
    let map = new Map();

    // 计算出现的频率
    for (const num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
    }

    const arr: number[] = [];

    for (const [key, value] of map.entries()) {
        if (arr.length === k) {
            if (value > map.get(arr[k - 1])) {
                arr.pop();
                arr.push(key);
            }
        } else {
            arr.push(key);
        }
        arr.sort((prev, next) => map.get(next) - map.get(prev));
    }
    return arr;
};
```

## 滑动窗口最大值

[地址](https://leetcode-cn.com/problems/sliding-window-maximum/)

思路：维护一个单调堆栈，最大的排在前面

```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
    let newArr: number[] = [];
    let stak: number[] = []; // 单调队列

    // 获取前k项单调序列
    for (let i = 0; i < k; i++) {
        while (stak.length > 0 && nums[i] >= nums[stak[stak.length - 1]]) {
            stak.pop();
        }
        stak.push(i);
    }
    newArr.push(nums[stak[0]]);

    // 获取从k项起的单调序列
    for (let i = k, len = nums.length; i < len; i++) {
        if (i - k === stak[0]) {
            stak.shift();
        }
        while (stak.length > 0 && nums[i] > nums[stak[stak.length - 1]]) {
            stak.pop(); // 弹出队尾
        }
        stak.push(i);
        newArr.push(nums[stak[0]]);
    }
    return newArr;
};
```

优化后：
```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
    let newArr: number[] = [];
    let stak: number[] = []; // 单调队列
    for (let i = 0, len = nums.length; i < len; i++) {
        while (stak.length > 0 && nums[i] > nums[stak[stak.length - 1]]) {
            stak.pop(); // 弹出队尾
        }
        stak.push(i);
        if (i - k >= -1) {
            if (i - k === stak[0]) {
                stak.shift();
            }
            newArr.push(nums[stak[0]]);
        }
    }
    return newArr;
};
```

## 重复的子字符串

[地址](https://leetcode-cn.com/problems/repeated-substring-pattern/)

```ts
// KMP
function repeatedSubstringPattern(s: string): boolean {
    if (s === '') {
        return true;
    }
    let j = 0;
    let next = [0];
    let len = s.length;

    // 获取next参数
    for (let i = 1; i < len; i++) {

        // 前缀与后缀不相等时
        while (j > 0 && s[j] !== s[i]) {
            j = next[j-1];
        }

        // 前缀和后缀相等时
        if (s[j] === s[i]) {
            j++;
        }
        next[i] = j;
    }
    return next[len - 1] !== 0 && len % (len - (next[len - 1])) === 0;
};
```

## 实现strStr

[地址](https://leetcode-cn.com/problems/implement-strstr/)

```ts
// KMP写法
function strStr(haystack: string, needle: string): number {
    if (needle === '') {
        return 0;
    }

    let j = 0;
    let next = [0];
    let jLen = needle.length;
    for (let i = 1, len = jLen; i < len; i++) {

        // 前缀与后缀不相等时
        while (j > 0 && needle[j] !== needle[i]) {
            j = next[j-1];
        }

        // 前缀和后缀相等时
        if (needle[j] === needle[i]) {
            j++;
        }
        next[i] = j;
    }
    next
    j = 0;
    for (let i = 0, len = haystack.length; i < len; i++) {

        // 查找next表的位置获取坐标
        while (j > 0 && haystack[i] !== needle[j]) {
            j = next[j-1];
        }
        if (haystack[i] === needle[j]) {
            j++;
        }

        if (j === jLen) {
            return i - jLen + 1;
        }
    }
    return -1;
};
```

```js
// 库语法
function strStr(haystack: string, needle: string): number {
    return haystack.indexOf(needle);
};
```

## 左旋字符串

[地址](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```ts
function reverseLeftWords(s: string, n: number): string {
    return s.slice(n, s.length) + s.slice(0, n);
};
```

## 翻转字符串里的单词

[地址](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```ts
function reverseWords(s: string): string {
    return s.split(' ').reverse().filter(Boolean).join(' ');
};
```

## 反转字符串2

[地址](https://leetcode-cn.com/problems/reverse-string-ii/)

```ts
function reverseStr(s: string, k: number): string {
    if (k === 1) {
        return s;
    }
    let sArr: string[] = s.split('');
    let prev = 0;
    let next = 0;
    let cur = '';
    for (let i = 0, len = s.length; i < len; i += 2 * k) {
        prev = i;
        next = i + k - 1 > len ? len - 1 : i + k - 1;
        while (prev <= next) {
            cur = sArr[prev];
            sArr[prev++] = sArr[next];
            sArr[next--] = cur;
        }
    }

    return sArr.join('');
};
```

```ts
function reverseStr(s: string, k: number): string {
    if (k === 1) {
        return s;
    }
    let sArr = s.split('');
    let prev = 0;
    let next = k - 1;
    let len = s.length;
    let cur;
    while (prev <= next) {
        cur = sArr[prev];
        sArr[prev++] = sArr[next];
        sArr[next--] = cur;

        if (next < prev) {
            prev =  Math.ceil(prev / k) * k + k;
            next = prev + k - 1;

            // 如果剩余字符少于k，那么剩余字符全部反转
            if (len - prev < k) {
                next = len - 1;
            }
        }
    }
    return sArr.join('');
};
```

## 反转字符串

[地址](https://leetcode-cn.com/problems/reverse-string/submissions/)

```ts
function reverseString(s: string[]): void {
    s.reverse();
};
```

```ts
function reverseString(s: string[]): void {
    let prev = 0;
    let next = s.length - 1;
    while (prev < next) {
        let cur = s[prev];
        s[prev++] = s[next];
        s[next--] = cur;
    }
};
```

## 四数之和

[地址](https://leetcode-cn.com/problems/4sum/submissions/)

```ts
function fourSum(nums: number[], target: number): number[][] {
    let len = nums.length;
    if (len < 4) {
        return [];
    }
    const arr = [];
    nums.sort((a, b) => a - b);
    for (let i = 0; i < len - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        for (let j = i +1; j < len - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) {
                continue;
            }
            let l = j + 1;
            let r = len - 1;
            while (l < r) {
                let sum = nums[l] + nums[r] + nums[i] + nums[j];
                if (sum < target) {
                    l++;
                    continue;
                }

                if (sum > target) {
                    r--;
                    continue;
                }

                arr.push([nums[i], nums[j], nums[l], nums[r]]);

                while (r > l && nums[r] === nums[--r]);

                while (r > l && nums[l] === nums[++l]);
            }

        }

    }
    return arr;
};
```

## 三数之和

[地址](https://leetcode-cn.com/problems/3sum/submissions/)

```ts
function threeSum(nums: number[]): number[][] {
    let len = nums.length;
    if (len < 3) {
        return [];
    }
    const arr = [];
    nums.sort((a, b) => a - b);
    for (let i = 0; i < len - 2; i++) {
        if (nums[i] > 0) {
            break;
        }

        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        let l = i + 1;
        let r = len - 1;
        while (l < r) {
            let sum = nums[l] + nums[r] + nums[i];
            if (sum < 0) {
                l++;
                continue;
            }

            if (sum > 0) {
                r--;
                continue;
            }

            arr.push([nums[i], nums[l], nums[r]]);

            while (r > l && nums[r] === nums[--r]);

            while (r > l && nums[l] === nums[++l]);
        }
    }
    return arr;
};
```

```ts
function threeSum(nums: number[]): number[][] {
    let len = nums.length;
    if (len < 3) {
        return [];
    }
    let set = new Set();
    nums.sort();
    for (let i = 0; i < len - 2; i++) {
        if (nums[i] > 0) {
            break;
        }
        let l = i + 1;
        let r = len - 1;
        while (l < r) {
            let sum = nums[l] + nums[r] + nums[i];
            if (sum < 0) {
                l++;
                continue;
            }

            if (sum > 0) {
                r--;
                continue;
            }

            set.add(`${nums[i]},${nums[l]},${nums[r]}`);
            l++;
            r--;
        }
    }
    return [...set].map(item => item.split(','));
};
```

## 赎金信

[地址](https://leetcode-cn.com/problems/ransom-note/)

```ts
function canConstruct(ransomNote: string, magazine: string): boolean {
    let map1 = new Map();
    for (const str of magazine) {
        map1.set(str, (map1.get(str) || 0) + 1);
    }

    for (const str of ransomNote) {
        if (!map1.get(str)) {
            return false;
        }
        map1.set(str, map1.get(str) - 1);
    }
    return true;
};
```

## 四数之和

[地址](https://leetcode-cn.com/problems/4sum-ii/submissions/)

减少map

```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let map1 = new Map();
    let n = 0;
    let sum = 0;
    for (const val of nums1) {
        for (const val2 of nums2) {
            sum = val + val2;
            map1.set(sum, (map1.get(sum) || 0) + 1);
        }
    }
    for (const val of nums3) {
        for (const val2 of nums4) {
            sum = val + val2;
            n += map1.get(-sum) || 0;
        }
    }
    return n;
};
```

map优化循环

```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let map1 = new Map();
    let map2 = new Map();
    let len = nums1.length;
    let n = 0;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            let sum = nums1[i] + nums2[j];
            map1.set(sum, (map1.get(sum || 0) + 1);
            sum = nums3[i] + nums4[j];
            map2.set(sum, (map2.get(sum) || 0) + 1);
        }
    }
    for (const [key, value] of map1.entries()) {
        n += value * (map2.get(-key) || 0)
    }
    return n;
};
```

遍历（超时）
```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let arr1 = [];
    let arr2 = [];
    let len = nums1.length;
    let n = 0;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            arr1.push(nums1[i] + nums2[j]);
            arr2.push(nums3[i] + nums4[j]);
        }
    }

    len = arr1.length;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            if (arr1[i] === -arr2[j]) {
                n++;
            }
        }
    }
    return n;
};
```

## 快乐数

[地址](https://leetcode-cn.com/problems/happy-number/submissions/)

```ts
function isHappy(n: number): boolean {
    let set = new Set([n]);

    while (n !== 1) {
        n = sum(n);
        if (set.has(n)) {
            return false;
        }
        set.add(n);
    }

    return true;
};

function sum(n: number) {
    let sum = 0;

    while (n) {
        sum += (n % 10) ** 2;
        n = Math.floor(n / 10);
    }
    return sum;
}
```

## 两个数组的交集

[地址](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```ts
function intersection(nums1: number[], nums2: number[]): number[] {
    let set = new Set(nums1);
    nums2 = [...new Set(nums2)];
    let arr: number[] = [];
    for (let i = 0, len = nums2.length; i < len; i++) {
        if (set.has(nums2[i])) {
            arr.push(nums2[i]);
        }
    }
    return arr;
};
```

## 有效的字母异位词

[地址](https://leetcode-cn.com/problems/valid-anagram/)

```ts
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) {
        return false;
    }
    let mapS = new Map();
    for (let i = 0, len = s.length; i < len; i++) {
        mapS.has(s[i]) ? mapS.set(s[i], mapS.get(s[i]) + 1) : mapS.set(s[i], 1);
        mapS.has(t[i]) ? mapS.set(t[i], mapS.get(t[i]) - 1) : mapS.set(t[i], -1);
    }

    for (const [key, value] of mapS) {
        if (value !== 0) {
            return false;
        }
    }

    return true;
};
```

```ts
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) {
        return false;
    }
    let arr = Array.from({ length: 26 }, () => 0);

    for (let i = 0, len = s.length; i < len; i++) {
        arr[s[i].charCodeAt(0) - 'a'.charCodeAt(0)] += 1;
        arr[t[i].charCodeAt(0) - 'a'.charCodeAt(0)] -= 1;
    }

    return arr.every(val => val === 0);
};
```

## 环形链表

[地址](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    let map = new Map();
    while (head) {
        if (map.has(head)) {
            return head;
        }
        map.set(head, true);
        head = head.next;
    }
    return null;
};
```

快慢指针：
1. slow走一步，fast走两步
2. slow与fast相遇的点开始，head与slow开始走，那么一定会在环相遇

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    let fast = head;
    let slow = head;
    while (slow && fast?.next) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            slow = head;
            while (fast !== slow) {
                fast = fast.next;
                slow = slow.next;
            }
            return slow;
        }
    }

    return null;
};
```

## 链表相交

[地址](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

```js
var getIntersectionNode = function(headA, headB) {
    let aLen = 0;
    let bLen = 0;
    let a = headA;
    let b = headB;

    // 获取A的长度
    while (a) {
        a = a.next;
        aLen++;
    }

    // 获取B的长度
    while (b) {
        b = b.next;
        bLen++;
    }

    // 判断A长度和B的长度，然后移动
    if (aLen > bLen) {
        let cur = aLen - bLen;
        while (cur--) {
            headA = headA.next;
        }
    } else {
        let cur = bLen - aLen;
        while (cur--) {
            headB = headB.next;
        }
    }

    // 同时移动，判断是否相等
    while (headA) {
        if (headA === headB) {
            return headA;
        }
        headA = headA.next;
        headB = headB.next;
    }
    return null;
};
```

## 删除链表的倒数第 N 个结点

[地址](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```ts
function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
    // head为空的情况
    if (!head) {
        return head;
    }

    let fast: ListNode | null = new ListNode(0, head); // 快指针
    let slow: ListNode | null = fast; // 慢指针

    while (n-- && fast) {
        fast = fast.next;
    }

    fast = fast?.next || null; // 还需要再移动一格
    if (!fast) {
        return head.next;
    }

    while (fast) {
        fast = fast.next;
        slow = slow!.next;
    }

    slow!.next = slow!.next?.next || null;

    return head;
};
```

## 两两交换链表中的节点

[地址](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```ts
function swapPairs(head: ListNode | null): ListNode | null {
    // 例如 1 -> 2 -> 3 -> 4 -> 5
    let node = new ListNode(0, head); // 0 ~ 5
    let cur = node;
    let temp = null;
    while (head?.next) {
        temp = head.next.next; // 保存临时变量到 temp = 3 -> 4 -> 5 || temp = 5
        cur.next = head.next; // cur = 0 -> 2 -> 3 -> 4 -> 5 || cur = 1 -> 4 -> 5
        head.next = temp; // head = 1 -> 3 -> 4 -> 5 || head = 3 -> 5
        cur.next.next = head; // cur = 0 -> 2 -> 1 -> 3 -> 4 -> 5 || cur = 1 -> 4 -> 3 -> 5
        cur = cur.next.next; // cur = 1 -> 3 -> 4 -> 5 || cur = 3 -> 5
        head = temp; // head = 3 -> 4 -> 5 || head = 5
    }
    return node.next;
};
```

## 反转链表

[地址](https://leetcode-cn.com/problems/reverse-linked-list/)

```ts
function reverseList(head: ListNode | null): ListNode | null {
    let cur = null;
    while (head) {
        cur = new ListNode(val, cur);
        head = head.next;
    }
    return cur;
};
```

```ts
function reverseList(head: ListNode | null): ListNode | null {
    if (!head?.next) {
        return head;
    }
    let prev = null;
    let cur = head;
    let temp;
    while (cur) {
        temp = cur.next; //  临时存储cur.next
        cur.next = prev;  // 改变cur.next位置
        prev = cur; // 改变prev指向
        cur = temp; // 继续循环
    }
    return prev;
};
```

## 设计链表

[地址](https://leetcode-cn.com/problems/design-linked-list/)

直接取，相互不关联：

```ts
class MyLinkedList {
    head: ListNode | null;
    constructor() {
        this.head = null;
    }

    get(index: number): number {
        let head = this.head;
        while (index && head) {
            head = head.next;
            index--;
        }
        return head ? head.val : -1;
    }

    addAtHead(val: number): void {
        if (!this.head) {
            this.head = {
                val,
                next: null
            }
            return;
        }
        this.head = {
            val,
            next: this.head
        }
    }

    addAtTail(val: number): void {
        if (!this.head) {
            this.head = {
                val,
                next: null
            }
            return;
        }
        let head = this.head;
        while (head.next) {
            head = head.next;
        }
        head.next = {
            val,
            next: null
        }
    }

    addAtIndex(index: number, val: number): void {
        if (index <= 0) {
            this.head = {
                val,
                next: this.head
            }
            return;
        }
        let head = this.head;
        while (index - 1 && head) {
            head = head.next;
            index--;
        }
        head && (head.next = {
            val,
            next: head.next
        });
    }

    deleteAtIndex(index: number): void {
        if (index < 0) {
            return;
        }
        if (index === 0) {
            this.head = this.head?.next || null;
            return;
        }
        let head = this.head;
        while (index - 1 && head) {
            head = head.next;
            index--;
        }
        head?.next && (head.next = head.next.next);
    }
}
```

相互关联：
```ts
class MyLinkedList {
    head: ListNode | null; // 首节点
    size: number;

    constructor() {
        this.head = null; // 链表
        this.size = 0;
    }

    get(index: number): number {
        if (index < 0 || index >= this.size) {
            return -1;
        }
        return this.getNode(index)!.val;
    }

    getNode(index: number) {
        if (index < 0 || index >= this.size) {
            return null;
        }
        let cur = new ListNode(0, this.head); // 加一个虚拟节点
        while (index-- >= 0) {
            cur = cur.next!;
        }
        return cur;
    }

    addAtHead(val: number): void {
        this.head = new ListNode(val, this.head);
        this.size++;
    }

    addAtTail(val: number): void {
        let cur = this.getNode(this.size - 1);
        this.size++;
        if (!cur) {
            this.head = new ListNode(val, null);
            return;
        }
        cur.next = new ListNode(val, null);
    }

    addAtIndex(index: number, val: number): void {
        if (index === 0) {
            this.addAtHead(val);
            return;
        }
        let node = this.getNode(index - 1);
        if (node) {
            node.next = new ListNode(val, node.next);
            this.size++;
        }
    }

    deleteAtIndex(index: number): void {
        if (index === 0 && this.head) {
            this.head = this.head.next;
            this.size--;
            return;
        }

        let node = this.getNode(index - 1);
        if (node && node.next) {
            node.next = node.next.next;
            this.size--;
        }
    }
}
```

## 移除链表元素

[地址](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```ts
function removeElements(head: ListNode | null, val: number): ListNode | null {
    // 设置一个虚拟节点
    let newHeader = new ListNode(0, head);
    let cur = newHeader;
    // 从第二个节点开始
    while (cur.next) {

        // 如果第二个节点等于要移除的元素，那么跳过第二个节点
        if (val === cur.next.val) {
            cur.next = cur.next.next;
            continue;
        }
        cur = cur.next;
    }

    return newHeader.next;
};

// 没有虚拟节点
function removeElements(head: ListNode | null, val: number): ListNode | null {
    if (head === null) {
        return head;
    }
    let cur = head;
    while (cur.next) {
        if (val === cur.next.val) {
            cur.next = cur.next.next;
            continue;
        }
        cur = cur.next;
    }

    return head.val === val ? head.next : head;
};
```

## 螺旋矩阵 II

[地址](https://leetcode-cn.com/problems/spiral-matrix-ii/)

进一步优化：

```ts
function generateMatrix(n: number): number[][] {
    let arr: number[][] = [...Array.from({ length: n }, () => [])];
    let prev = 0;
    let val = 1; // 初始值
    let next = n - 1;
    while(prev < next) {
        let des = next - prev; // 差值
        // 从左到右，从上到下，从右到左，从下到上
        for (let j = prev; j < next; j++) {
            arr[prev][j] = val;
            arr[j][next] = val + des;
            arr[next][next+prev-j] = val + 2 * des
            arr[next+prev-j][prev] = val + 3 * des;
            val++;
        }
        val += 3 * des;
        prev++;
        next--;
    }

    // 如果prev和next相等了
    if (prev === next) {
        arr[prev][next] = val;
    }
    return arr;
};
```

最开始写法，可能比较好理解：
```ts
function generateMatrix(n: number): number[][] {
    let arr: number[][] = [...Array.from({ length: n }, () => [])];
    let prev = 0;
    let val = 1; // 初始值
    let next = n - 1;
    while(prev < next) {

        // 从左到右
        for (let j = prev; j < next; j++) {
            arr[prev][j] = val++;
        }

        // 从上到下
        for (let j = prev; j < next; j++) {
            arr[j][next] = val++;
        }

        // 从右到左
        for (let j = next; j > prev; j--) {
            arr[next][j] = val++;
        }

        // 从下到上
        for (let j = next; j > prev; j--) {
            arr[j][prev] = val++;
        }

        prev++;
        next--;
    }

    // 如果prev和next相等了
    if (prev === next) {
        arr[prev][next] = val;
    }
    return arr;
};
```

## 长度最小的子数组

采用了滑动窗口的思想，sum为加和的值，一旦sum超过了target，那么prev就需要移动了，移动的值为sum一直减后小于target的值

```ts
function minSubArrayLen(target: number, nums: number[]): number {
    let sum = 0;
    let minIndexLen = Number.MAX_SAFE_INTEGER; // 先设置了极大值
    let prev = 0; // 前面的位置
    for (let i = 0, len = nums.length; i < len; i++) {
        sum += nums[i];
        while (sum >= target) {
            // 判断哪一个最小
            minIndexLen = Math.min(minIndexLen, i - prev + 1);
            sum -= nums[prev++];
        }
    }
    return minIndexLen === Number.MAX_SAFE_INTEGER ? 0 : minIndexLen;
};
```

## 移除元素

```ts
function removeElement(nums: number[], val: number): number {
    let index = 0;
    while (index < nums.length) {
        if (nums[index] === val) {
            nums.splice(index, 1);
        } else {
            index++;
        }
    }
    return nums.length;
};
```

## 二分查找

```ts
function search(nums: number[], target: number): number {
  // 二分查找，左闭右闭
  let prev = 0;
  let next = nums.length - 1;
  while (prev <= next) {
    let half = Math.floor((prev + next) / 2);
    if (nums[half] > target) {
      next = half - 1;
    } else if (nums[half] < target) {
      prev = half + 1;
    } else {
      return half;
    }
  }
  return -1;
};
```

## 两数之和

通过hash表得到对应的值

```ts
function twoSum(nums: number[], target: number): number[] {
  let map = new Map();
  for (let i = 0, len = nums.length; i < len; i++) {
     if (map.has(nums[i])) {
         return [map.get(nums[i]), i];
     }
     map.set(target - nums[i], i);
  }
};
```

## 无重复字符的最长子串

```ts
function lengthOfLongestSubstring(s: string): number {
  let max = 0;
  let map = new Map();
  let prevIndex = 0;
  // 循环该字符
  for (let i = 0, len = s.length; i < len; i++) {

      // 判断是否存在该元素，存在的话则向右滑动
      if (map.has(s[i]) && map.get(s[i]) >= prevIndex) {
          prevIndex = map.get(s[i]) + 1;
      }
      max = Math.max(max, i - prevIndex + 1);
      map.set(s[i], i);
  }
  return max;
};
```

## 字符串相加

```ts
function addStrings(num1: string, num2: string): string {
  // 判断哪一个最长，较短的使用0补足
  let len1 = num1.length;
  let len2 = num2.length;
  if (len1 < len2) {
    num1 = num1.padStart(len2, '0');
  } else {
    num2 = num2.padStart(len1, '0');
  }

  // 对数字进行循环，从最后一项开始相加
  let str = '';
  let n = 0; // 过程中如果大于10需要
  for (let i = num1.length - 1; i >= 0; i--) {
      let m = Number(num1[i]) + Number(num2[i]) + n;
      str = m % 10 + str;
      n = Math.floor(m / 10);
  }

  // 如果n还有保留，则需要整体加1
  if (n === 1) {
    str = n + str;
  }
  return str;
};
```