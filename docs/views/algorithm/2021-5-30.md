---
title: 算法打卡
date: 2021-08-31
categories: 算法
tags:
 - 打卡
 - 算法
---

## 二叉树的所有路径

[地址](https://leetcode-cn.com/problems/binary-tree-paths/)
```ts
function binaryTreePaths(root: TreeNode | null): string[] {
    let result: string[] = [];
    let getPath = (root: TreeNode | null, path: string, result: string[] = []) => {
        if (!root) {
            return result;
        }
        path += `${root.val}`;
        if (!root.left && !root.right) {
            return result.push(path);
        }
        root.left && getPath(root.left, path + '->', result);
        root.right && getPath(root.right, path + '->', result);
    }
    getPath(root, '', result)
    return result;
};
```

## 平衡二叉树

[地址](https://leetcode-cn.com/problems/balanced-binary-tree/)

```ts
function isBalanced(root: TreeNode | null): boolean {
    let getDepth = (root: TreeNode | null) => {
        if (!root) {
            return 0;
        }

        // 左树高度
        let leftDepth = getDepth(root.left);
        if (leftDepth === -1) {
            return -1;
        }

        // 右树高度
        let rightDepth = getDepth(root.right);
        if (rightDepth === -1) {
            return -1;
        }

        // 如果高度差大于1则直接返回-1
        return Math.abs(leftDepth - rightDepth) > 1 ? -1 : 1 + Math.max(leftDepth, rightDepth);
    }
    
    return getDepth(root) !== -1;
};
```

## 完全二叉树的节点个数

[地址](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

### 递归 + 树结构特征

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    let leftDepth = 0;
    let rightDepth = 0;
    let left = root;
    let right = root;

    while(left) {
        left = left.left;
        leftDepth++;
    }

    while (right) {
        right = right.right;
        rightDepth++;
    }
    
    // 等比数列公式 Sn = a0 * (1 - q^n) / (1 - q) 
    // 这里的目的是求取完全二叉树时获得的节点数
    leftDepth
    if (leftDepth === rightDepth) {
        return 2 ** leftDepth - 1;
    }
    return 1 + countNodes(root.right) + countNodes(root.left);
};
```

### 递归

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    if (!root.left && !root.right) {

        // root节点加1
        return 1;
    }
    
    if (!root.left) {
        return 1 + countNodes(root.right);
    }

    if (!root.right) {
        return 1 + countNodes(root.left);
    }

    return 1 + countNodes(root.right) + countNodes(root.left);
};

function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }
    return 1 + countNodes(root.right) + countNodes(root.left);
};
```

### 迭代

```ts
function countNodes(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    let count = 0;
    let stack: TreeNode[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        count += len;
    }
    return count;
};
```

## 二叉树的最小深度

[地址](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

### 迭代

```ts
function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    let stack: TreeNode[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();

            if (node.left === null || node.right === null) {
                return depth + 1;
            }

            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        depth++;
    }
    return depth;
};
```

### 递归

```ts
function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    const cascader = (root: TreeNode | null, depth = 0) => {
        if (!root.left && !root.right) {
            return depth;
        }

        // 如果左树为null，那么需要计算右树的
        if (!root.left) {
            return cascader(root.right, depth + 1);
        }

        // 如果右树为null，那么计算左树的
        if (!root.right) {
            return cascader(root.left, depth + 1);
        }

        let leftDepth = cascader(root.left, depth + 1);
        let rightDepth = cascader(root.right, depth + 1);
        return Math.min(leftDepth, rightDepth);
    }
    return cascader(root, 0) + 1;
};


function minDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    if (!root.left && !root.right) {
        return 1;
    }

    if (!root.left) {
        return 1 + minDepth(root.right);
    }

    if (!root.right) {
        return 1 + minDepth(root.left);
    }

    return 1 + Math.min(minDepth(root.right), minDepth(root.left));
};
```

## N 叉树的最大深度

[地址](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

### 递归

```ts
function maxDepth(root: Node | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    if (root.children?.length > 0) {
        for (let i = 0; i < root.children.length; i++) {
            depth = Math.max(maxDepth(root.children[i]), depth);
        }
    }
    return 1 + depth;
};
```

### 迭代

```ts
function maxDepth(root: Node | null): number {
    if (root === null) {
        return 0;
    }
    let depth = 0;
    let stack: Node[] = [root];
    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            if (node.children?.length > 0) {
                stack.push(...node.children);
            }
        }
        depth++;
    }
    return depth;
};
```

## 二叉树的最大深度

[地址](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

### 迭代

```ts
function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    let stack: TreeNode[] = [root];
    let depth = 0;
    while(stack.length) {
        let size = stack.length;
        for (let i = 0; i < size; i++) {
            let node = stack.shift();
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        depth++;
    }
    return depth;
};
```

### 递归

```ts
function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }

    let cascaderTree = (root: TreeNode | null, depth = 0) => {
        if (root === null) {
            return depth;
        }
        let leftDepth = cascaderTree(root.left, depth + 1);
        let rightDepth = cascaderTree(root.right, depth + 1);
        return Math.max(leftDepth, rightDepth);
    }
    return cascaderTree(root);
};

function maxDepth(root: TreeNode | null): number {
    if (root === null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```
## 对称二叉树

[地址](https://leetcode-cn.com/problems/symmetric-tree/)

### 迭代

```ts
// 迭代1
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    let stack: TreeNode[] = [root.left, root.right];
    while (stack.length) {
        let len = stack.length;
        let curNum: number[] = [];
        for (let i = 0, halfLen = len / 2; i < len; i++) {
            let node = stack.shift();

            // 前一半取值后一半去值
            if (i < halfLen) {
                curNum.push(node?.val);
            } else {
                if (curNum.pop() !== node?.val) {
                    return false;
                }
            }

            node && stack.push(node.left);
            node && stack.push(node.right);
        }
    }

    return true;
};

// 迭代2
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    let queue: TreeNode[] = [root.left, root.right];
    while(queue.length) {
        let leftNode = queue.shift();
        let rightNode = queue.shift();

        // 都为null的情况
        if (!leftNode && !rightNode) {
            continue;
        }

        if (!leftNode && rightNode || (leftNode && !rightNode) || (leftNode.val !== rightNode.val)) {
            return false;
        }

        queue.push(leftNode.left);
        queue.push(rightNode.right);
        queue.push(leftNode.right);
        queue.push(rightNode.left);
    }
    return true;
};
```

### 递归

```ts
function isSymmetric(root: TreeNode | null): boolean {
    if (root === null) {
        return true;
    }

    const compare = (left: TreeNode | null, right: TreeNode | null) => {
        if (!left && right) {
            return false;
        } else if (!right && left) {
            return false;
        } else if (!left && !right) {
            return true;
        } else if (left.val !== right.val) {
            return false;
        }

        // 比较外侧是否对称
        const outside = compare(left.left, right.right);
        // 比较内侧是否对称
        const inside = compare(left.right, right.left);

        return outside && inside;
    }
    return compare(root.left, root.right);
};
```
## 翻转二叉树

### 层序遍历

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while(stack.length) {
        let len = stack.length;
        for (let i = 0; i < len; i++) {
            let node = stack.shift()!;

            // 每层都反转
            let temp = node.left;
            node.left = node.right;
            node.right = temp;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
    }
    return root;
};
```

### 递归

```ts
// 递归遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    if (root === null) {
        return root;
    }
  
    let temp = root.left;
    root.left = root.right;
    root.right = temp;
    invertTree(root.left);
    invertTree(root.right);
    return root;
};
```

### 迭代

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    if (root === null) {
        return root;
    }

    let stack: TreeNode[] = [root];
  
    while(stack.length) {
        let node = stack.pop();
        let temp = node.left;
        node.left = node.right;
        node.right = temp;
        node.left && stack.push(node.left);
        node.right && stack.push(node.right);
    }
    return root;
};
```
## 填充每个节点的下一个右侧节点指针 II

[地址](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

代码与1一致

## 填充每个节点的下一个右侧节点指针

[地址](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```ts
function connect(root: Node1 | null): Node1 | null {
    let stack: Node1[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let curNode = null;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            curNode && (curNode.next = node);
            curNode = node;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        curNode.next = null;
    }
    
    return root;
};
```

## 在每个树行中找最大值

[地址](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```ts
function largestValues(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let max = -Infinity;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            max = Math.max(max, node.val);
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        result.push(max);
    }
    return result;
};
```

## N 叉树的层序遍历

[地址](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```ts
function levelOrder(root: Node | null): number[][] {
    let result: number[][] = [];
    let stack: Node[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let curStack = [];
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            curStack.push(node.val);
            node.children && stack.push(...node.children);
        }
        result.push(curStack);
    }
    return result;
};
```

## 二叉树的层平均值

[地址](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```ts
function averageOfLevels(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];

    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let len = stack.length;
        let sum = 0;
        for (let i = 0; i < len; i++) {
            let node = stack.shift();
            sum += node.val;
            node.left && stack.push(node.left);
            node.right && stack.push(node.right);
        }
        result.push(sum / len);
    }
    return result;
};
```

## 二叉树的右视图

[地址](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```ts
function rightSideView(root: TreeNode | null): number[] {
    let result: number[] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.push(curLevel.pop()); // 取最后一个
    }
    return result;
}

// 优化
function rightSideView(root: TreeNode | null): number[] {
    let result: number[] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            if (i === len - 1) {
                result.push(node.val);
            }
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
    }
    return result;
}
```

## 二叉树的层序遍历2

[地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```ts
function levelOrderBottom(root: TreeNode | null): number[][] {
    let result: number[][] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.unshift(curLevel);
    }
    return result;
}
```

## 二叉树的层序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let result: number[][] = [];
    let queue: TreeNode[] = [];
    if (root !== null) {
        queue.push(root);
    }

    while (queue.length) {
        let len = queue.length;
        let curLevel: number[] = [];
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        result.push(curLevel);
    }
    return result;
}
```

## 二叉树的后序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```ts
function postorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [root];
    let cur = null;

    // 顺序中右左
    while (stack.length) {
        cur = stack.pop();
        arr.push(cur.val);
        cur.left && (stack.push(cur.left)); // 左子树后出栈
        cur.right && (stack.push(cur.right)); // 右子树先出栈
    }
    
    return arr.reverse();
};
```

### 标记法

```ts
function postorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            node.right && stack.push(node.right);
            node.left && stack.push(node.left);
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 二叉树的中序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 迭代法

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [];
    let cur = root;
    while (cur !== null || stack.length) {
       // 先一直到左边
        if (cur !== null) {
            stack.push(cur);
            cur = cur.left;
            continue;
        }
    
        cur = stack.pop(); // 出栈
        arr.push(cur.val);
        cur = cur.right; // 出栈的元素是否有右子树
    }
    
    return arr;
};
```

### 标记法

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            node.right && stack.push(node.right);
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            node.left && stack.push(node.left);
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 二叉树的前序遍历

[地址](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 递归

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    let arr: number[] = [];
    let cascader = (tree: TreeNode) => {
        if (tree === null) {
            return;
        }
        arr.push(tree.val); // 中
        cascader(tree.left); // 左
        cascader(tree.right); // 右
    }
    cascader(root);
    return arr;
};
```

### 迭代法

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    if (root === null) {
        return [];
    }
    let arr: number[] = [];
    let stack: TreeNode[] = [root];
    let cur = null;
    while (stack.length) {
        cur = stack.pop(); // 中间最先出栈，之后左子树，之后右子树
        arr.push(cur.val);
        cur.right && (stack.push(cur.right)); // 右子树后出栈
        cur.left && (stack.push(cur.left)); // 左子树先出栈
    }
    
    return arr;
};
```

### 标记法

```ts
function preorderTraversal(root: TreeNode | null): number[] {
    let result: number[] = [];
    let stack: TreeNode[] = [];
    if (root !== null) {
        stack.push(root);
    }

    while (stack.length) {
        let node = stack.pop();
        if (node !== null) {
            node.right && stack.push(node.right);
            node.left && stack.push(node.left);
            stack.push(node);
            stack.push(null); // 为了确保else的时候取到中间节点的值
            continue;
        }
        node = stack.pop(); // 这里都是取中间节点的值
        result.push(node.val);
    }
    return result;
};
```

## 前 K 个高频元素

[地址](https://leetcode-cn.com/problems/top-k-frequent-elements/)

### 解法二

```ts
function topKFrequent(nums: number[], k: number): number[] {
    let map = new Map();

    // 计算出现的频率
    for (const num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
    }
    console.log(Array.from(map.entries()));
    
    let arr: [number, number][] = Array.from(map.entries()).sort((prev, next) => next[1] - prev[1]);
    let newArr: number[] = [];
    for (let i = 0; i < k; i++) {
        newArr.push(arr[i][0]);
    }
   
    return newArr;
};
```

### 解法一

```ts
function topKFrequent(nums: number[], k: number): number[] {
    let map = new Map();

    // 计算出现的频率
    for (const num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
    }

    const arr: number[] = [];

    for (const [key, value] of map.entries()) {
        if (arr.length === k) {
            if (value > map.get(arr[k - 1])) {
                arr.pop();
                arr.push(key);
            }
        } else {
            arr.push(key);
        }
        arr.sort((prev, next) => map.get(next) - map.get(prev));
    }
    return arr;
};
```

## 滑动窗口最大值

[地址](https://leetcode-cn.com/problems/sliding-window-maximum/)

思路：维护一个单调堆栈，最大的排在前面

```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
    let newArr: number[] = [];
    let stak: number[] = []; // 单调队列

    // 获取前k项单调序列
    for (let i = 0; i < k; i++) {
        while (stak.length > 0 && nums[i] >= nums[stak[stak.length - 1]]) {
            stak.pop();
        }
        stak.push(i);
    }
    newArr.push(nums[stak[0]]);

    // 获取从k项起的单调序列
    for (let i = k, len = nums.length; i < len; i++) {
        if (i - k === stak[0]) {
            stak.shift();
        }
        while (stak.length > 0 && nums[i] > nums[stak[stak.length - 1]]) {
            stak.pop(); // 弹出队尾
        }
        stak.push(i);
        newArr.push(nums[stak[0]]);
    }
    return newArr;
};
```

优化后：
```ts
function maxSlidingWindow(nums: number[], k: number): number[] {
    let newArr: number[] = [];
    let stak: number[] = []; // 单调队列
    for (let i = 0, len = nums.length; i < len; i++) {
        while (stak.length > 0 && nums[i] > nums[stak[stak.length - 1]]) {
            stak.pop(); // 弹出队尾
        }
        stak.push(i);
        if (i - k >= -1) {
            if (i - k === stak[0]) {
                stak.shift();
            }
            newArr.push(nums[stak[0]]);
        }
    }
    return newArr;
};
```

## 重复的子字符串

[地址](https://leetcode-cn.com/problems/repeated-substring-pattern/)

```ts
// KMP
function repeatedSubstringPattern(s: string): boolean {
    if (s === '') {
        return true;
    }
    let j = 0;
    let next = [0];
    let len = s.length;

    // 获取next参数
    for (let i = 1; i < len; i++) {

        // 前缀与后缀不相等时
        while (j > 0 && s[j] !== s[i]) {
            j = next[j-1];
        }
        
        // 前缀和后缀相等时
        if (s[j] === s[i]) {
            j++;
        }
        next[i] = j;
    }
    return next[len - 1] !== 0 && len % (len - (next[len - 1])) === 0;
};
```

## 实现strStr

[地址](https://leetcode-cn.com/problems/implement-strstr/)

```ts
// KMP写法
function strStr(haystack: string, needle: string): number {
    if (needle === '') {
        return 0;
    }

    let j = 0;
    let next = [0];
    let jLen = needle.length;
    for (let i = 1, len = jLen; i < len; i++) {

        // 前缀与后缀不相等时
        while (j > 0 && needle[j] !== needle[i]) {
            j = next[j-1];
        }
        
        // 前缀和后缀相等时
        if (needle[j] === needle[i]) {
            j++;
        }
        next[i] = j;
    }
    next
    j = 0;
    for (let i = 0, len = haystack.length; i < len; i++) {

        // 查找next表的位置获取坐标
        while (j > 0 && haystack[i] !== needle[j]) {
            j = next[j-1];
        }
        if (haystack[i] === needle[j]) {
            j++;
        }
        
        if (j === jLen) {
            return i - jLen + 1;
        }
    }
    return -1;
};
```

```js
// 库语法
function strStr(haystack: string, needle: string): number {
    return haystack.indexOf(needle);
};
```

## 左旋字符串

[地址](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```ts
function reverseLeftWords(s: string, n: number): string {
    return s.slice(n, s.length) + s.slice(0, n);
};
```

## 翻转字符串里的单词

[地址](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```ts
function reverseWords(s: string): string {
    return s.split(' ').reverse().filter(Boolean).join(' ');
};
```

## 反转字符串2

[地址](https://leetcode-cn.com/problems/reverse-string-ii/)

```ts
function reverseStr(s: string, k: number): string {
    if (k === 1) {
        return s;
    }
    let sArr: string[] = s.split('');
    let prev = 0;
    let next = 0;
    let cur = '';
    for (let i = 0, len = s.length; i < len; i += 2 * k) {
        prev = i;
        next = i + k - 1 > len ? len - 1 : i + k - 1;
        while (prev <= next) {
            cur = sArr[prev];
            sArr[prev++] = sArr[next];
            sArr[next--] = cur;
        }
    }
    
    return sArr.join('');
};
```

```ts
function reverseStr(s: string, k: number): string {
    if (k === 1) {
        return s;
    }
    let sArr = s.split('');
    let prev = 0;
    let next = k - 1;
    let len = s.length;
    let cur;
    while (prev <= next) {
        cur = sArr[prev];
        sArr[prev++] = sArr[next];
        sArr[next--] = cur;

        if (next < prev) {
            prev =  Math.ceil(prev / k) * k + k;
            next = prev + k - 1;
            
            // 如果剩余字符少于k，那么剩余字符全部反转
            if (len - prev < k) {
                next = len - 1;
            }
        }
    }
    return sArr.join('');
};
```

## 反转字符串

[地址](https://leetcode-cn.com/problems/reverse-string/submissions/)

```ts
function reverseString(s: string[]): void {
    s.reverse();
};
```

```ts
function reverseString(s: string[]): void {
    let prev = 0;
    let next = s.length - 1;
    while (prev < next) {
        let cur = s[prev];
        s[prev++] = s[next];
        s[next--] = cur;
    }
};
```

## 四数之和

[地址](https://leetcode-cn.com/problems/4sum/submissions/)

```ts
function fourSum(nums: number[], target: number): number[][] {
    let len = nums.length;
    if (len < 4) {
        return [];
    }
    const arr = [];
    nums.sort((a, b) => a - b);
    for (let i = 0; i < len - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        for (let j = i +1; j < len - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) {
                continue;
            }
            let l = j + 1;
            let r = len - 1;
            while (l < r) {
                let sum = nums[l] + nums[r] + nums[i] + nums[j];
                if (sum < target) {
                    l++;
                    continue;
                }
    
                if (sum > target) {
                    r--;
                    continue;
                }
    
                arr.push([nums[i], nums[j], nums[l], nums[r]]);
    
                while (r > l && nums[r] === nums[--r]);
    
                while (r > l && nums[l] === nums[++l]);
            } 
            
        }
      
    }
    return arr;
};
```

## 三数之和

[地址](https://leetcode-cn.com/problems/3sum/submissions/)

```ts
function threeSum(nums: number[]): number[][] {
    let len = nums.length;
    if (len < 3) {
        return [];
    }
    const arr = [];
    nums.sort((a, b) => a - b);
    for (let i = 0; i < len - 2; i++) {
        if (nums[i] > 0) {
            break;
        }

        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        let l = i + 1;
        let r = len - 1;
        while (l < r) {
            let sum = nums[l] + nums[r] + nums[i];
            if (sum < 0) {
                l++;
                continue;
            }

            if (sum > 0) {
                r--;
                continue;
            }

            arr.push([nums[i], nums[l], nums[r]]);

            while (r > l && nums[r] === nums[--r]);

            while (r > l && nums[l] === nums[++l]);
        }
    }
    return arr;
};
```

```ts
function threeSum(nums: number[]): number[][] {
    let len = nums.length;
    if (len < 3) {
        return [];
    }
    let set = new Set();
    nums.sort();
    for (let i = 0; i < len - 2; i++) {
        if (nums[i] > 0) {
            break;
        }
        let l = i + 1;
        let r = len - 1;
        while (l < r) {
            let sum = nums[l] + nums[r] + nums[i];
            if (sum < 0) {
                l++;
                continue;
            }

            if (sum > 0) {
                r--;
                continue;
            }

            set.add(`${nums[i]},${nums[l]},${nums[r]}`);
            l++;
            r--;
        }
    }
    return [...set].map(item => item.split(','));
};
```

## 赎金信

[地址](https://leetcode-cn.com/problems/ransom-note/)

```ts
function canConstruct(ransomNote: string, magazine: string): boolean {
    let map1 = new Map();
    for (const str of magazine) {
        map1.set(str, (map1.get(str) || 0) + 1);
    }

    for (const str of ransomNote) {
        if (!map1.get(str)) {
            return false;
        }
        map1.set(str, map1.get(str) - 1);
    }
    return true;
};
```

## 四数之和

[地址](https://leetcode-cn.com/problems/4sum-ii/submissions/)

减少map

```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let map1 = new Map();
    let n = 0;
    let sum = 0;
    for (const val of nums1) {
        for (const val2 of nums2) {
            sum = val + val2;
            map1.set(sum, (map1.get(sum) || 0) + 1);
        }
    }
    for (const val of nums3) {
        for (const val2 of nums4) {
            sum = val + val2;
            n += map1.get(-sum) || 0;
        }
    }
    return n;
};
```

map优化循环

```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let map1 = new Map();
    let map2 = new Map();
    let len = nums1.length;
    let n = 0;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            let sum = nums1[i] + nums2[j];
            map1.set(sum, (map1.get(sum || 0) + 1);
            sum = nums3[i] + nums4[j];
            map2.set(sum, (map2.get(sum) || 0) + 1);
        }
    }
    for (const [key, value] of map1.entries()) {
        n += value * (map2.get(-key) || 0)     
    }
    return n;
};
```

遍历（超时）
```ts
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
    // 两两合并
    let arr1 = [];
    let arr2 = [];
    let len = nums1.length;
    let n = 0;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            arr1.push(nums1[i] + nums2[j]);
            arr2.push(nums3[i] + nums4[j]); 
        }
    }

    len = arr1.length;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            if (arr1[i] === -arr2[j]) {
                n++;
            }
        }
    }
    return n;
};
```

## 快乐数

[地址](https://leetcode-cn.com/problems/happy-number/submissions/)

```ts
function isHappy(n: number): boolean {
    let set = new Set([n]);

    while (n !== 1) {
        n = sum(n);
        if (set.has(n)) {
            return false;
        }
        set.add(n);
    }

    return true;
};

function sum(n: number) {
    let sum = 0;

    while (n) {
        sum += (n % 10) ** 2;
        n = Math.floor(n / 10);
    }
    return sum;
}
```

## 两个数组的交集

[地址](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```ts
function intersection(nums1: number[], nums2: number[]): number[] {
    let set = new Set(nums1);
    nums2 = [...new Set(nums2)];
    let arr: number[] = [];
    for (let i = 0, len = nums2.length; i < len; i++) {
        if (set.has(nums2[i])) {
            arr.push(nums2[i]);
        }
    }
    return arr;
};
```

## 有效的字母异位词

[地址](https://leetcode-cn.com/problems/valid-anagram/)

```ts
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) {
        return false;
    }
    let mapS = new Map();
    for (let i = 0, len = s.length; i < len; i++) {
        mapS.has(s[i]) ? mapS.set(s[i], mapS.get(s[i]) + 1) : mapS.set(s[i], 1);
        mapS.has(t[i]) ? mapS.set(t[i], mapS.get(t[i]) - 1) : mapS.set(t[i], -1);
    }

    for (const [key, value] of mapS) {
        if (value !== 0) {
            return false;
        }
    }

    return true;
};
```

```ts
function isAnagram(s: string, t: string): boolean {
    if (s.length !== t.length) {
        return false;
    }
    let arr = Array.from({ length: 26 }, () => 0);
    
    for (let i = 0, len = s.length; i < len; i++) {
        arr[s[i].charCodeAt(0) - 'a'.charCodeAt(0)] += 1;
        arr[t[i].charCodeAt(0) - 'a'.charCodeAt(0)] -= 1;
    }

    return arr.every(val => val === 0);
};
```

## 环形链表

[地址](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    let map = new Map();
    while (head) {
        if (map.has(head)) {
            return head;
        }
        map.set(head, true);
        head = head.next;
    }
    return null;
};
```

快慢指针：
1. slow走一步，fast走两步
2. slow与fast相遇的点开始，head与slow开始走，那么一定会在环相遇

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    let fast = head;
    let slow = head;
    while (slow && fast?.next) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            slow = head;
            while (fast !== slow) {
                fast = fast.next;
                slow = slow.next;
            }
            return slow;
        }
    }
   
    return null;
};
```

## 链表相交

[地址](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

```js
var getIntersectionNode = function(headA, headB) {
    let aLen = 0;
    let bLen = 0;
    let a = headA;
    let b = headB;

    // 获取A的长度
    while (a) {
        a = a.next;
        aLen++;
    }

    // 获取B的长度
    while (b) {
        b = b.next;
        bLen++;
    }

    // 判断A长度和B的长度，然后移动
    if (aLen > bLen) {
        let cur = aLen - bLen;
        while (cur--) {
            headA = headA.next;
        }
    } else {
        let cur = bLen - aLen;
        while (cur--) {
            headB = headB.next;
        }
    }

    // 同时移动，判断是否相等
    while (headA) {
        if (headA === headB) {
            return headA;
        }
        headA = headA.next;
        headB = headB.next;
    }
    return null;
};
```

## 删除链表的倒数第 N 个结点

[地址](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```ts
function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
    // head为空的情况
    if (!head) {
        return head;
    }

    let fast: ListNode | null = new ListNode(0, head); // 快指针
    let slow: ListNode | null = fast; // 慢指针

    while (n-- && fast) {
        fast = fast.next;
    }

    fast = fast?.next || null; // 还需要再移动一格
    if (!fast) {
        return head.next;
    }

    while (fast) {
        fast = fast.next;
        slow = slow!.next;
    }

    slow!.next = slow!.next?.next || null;
    
    return head;
};
```

## 两两交换链表中的节点

[地址](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```ts
function swapPairs(head: ListNode | null): ListNode | null {
    // 例如 1 -> 2 -> 3 -> 4 -> 5
    let node = new ListNode(0, head); // 0 ~ 5
    let cur = node;
    let temp = null;
    while (head?.next) {
        temp = head.next.next; // 保存临时变量到 temp = 3 -> 4 -> 5 || temp = 5
        cur.next = head.next; // cur = 0 -> 2 -> 3 -> 4 -> 5 || cur = 1 -> 4 -> 5
        head.next = temp; // head = 1 -> 3 -> 4 -> 5 || head = 3 -> 5
        cur.next.next = head; // cur = 0 -> 2 -> 1 -> 3 -> 4 -> 5 || cur = 1 -> 4 -> 3 -> 5
        cur = cur.next.next; // cur = 1 -> 3 -> 4 -> 5 || cur = 3 -> 5
        head = temp; // head = 3 -> 4 -> 5 || head = 5
    }
    return node.next;
};
```

## 反转链表

[地址](https://leetcode-cn.com/problems/reverse-linked-list/)

```ts
function reverseList(head: ListNode | null): ListNode | null {
    let cur = null;
    while (head) {
        cur = new ListNode(val, cur);
        head = head.next;
    }
    return cur;
};
```

```ts
function reverseList(head: ListNode | null): ListNode | null {
    if (!head?.next) {
        return head;
    }
    let prev = null;
    let cur = head;
    let temp;
    while (cur) {
        temp = cur.next; //  临时存储cur.next
        cur.next = prev;  // 改变cur.next位置
        prev = cur; // 改变prev指向
        cur = temp; // 继续循环
    }
    return prev;
};
```

## 设计链表

[地址](https://leetcode-cn.com/problems/design-linked-list/)

直接取，相互不关联：

```ts
class MyLinkedList {
    head: ListNode | null;
    constructor() {
        this.head = null;
    }

    get(index: number): number {
        let head = this.head;
        while (index && head) {
            head = head.next;
            index--;
        }
        return head ? head.val : -1; 
    }

    addAtHead(val: number): void {
        if (!this.head) {
            this.head = {
                val,
                next: null
            }
            return;
        }
        this.head = {
            val,
            next: this.head
        }
    }

    addAtTail(val: number): void {
        if (!this.head) {
            this.head = {
                val,
                next: null
            }
            return;
        }
        let head = this.head;
        while (head.next) {
            head = head.next;
        }
        head.next = {
            val,
            next: null
        }
    }

    addAtIndex(index: number, val: number): void {
        if (index <= 0) {
            this.head = {
                val,
                next: this.head
            }
            return;
        }
        let head = this.head;
        while (index - 1 && head) {
            head = head.next;
            index--;
        }
        head && (head.next = {
            val,
            next: head.next
        });
    }

    deleteAtIndex(index: number): void {
        if (index < 0) {
            return;
        }
        if (index === 0) {
            this.head = this.head?.next || null;
            return;
        }
        let head = this.head;
        while (index - 1 && head) {
            head = head.next;
            index--;
        }
        head?.next && (head.next = head.next.next);
    }
}
```

相互关联：
```ts
class MyLinkedList {
    head: ListNode | null; // 首节点
    size: number;

    constructor() {
        this.head = null; // 链表
        this.size = 0;
    }

    get(index: number): number {
        if (index < 0 || index >= this.size) {
            return -1;
        }
        return this.getNode(index)!.val;
    }

    getNode(index: number) {
        if (index < 0 || index >= this.size) {
            return null;
        }
        let cur = new ListNode(0, this.head); // 加一个虚拟节点
        while (index-- >= 0) {
            cur = cur.next!;
        }
        return cur;
    }

    addAtHead(val: number): void {
        this.head = new ListNode(val, this.head);
        this.size++;
    }

    addAtTail(val: number): void {
        let cur = this.getNode(this.size - 1);
        this.size++;
        if (!cur) {
            this.head = new ListNode(val, null);
            return;
        }
        cur.next = new ListNode(val, null);
    }

    addAtIndex(index: number, val: number): void {
        if (index === 0) {
            this.addAtHead(val);
            return;
        }
        let node = this.getNode(index - 1);
        if (node) {
            node.next = new ListNode(val, node.next);
            this.size++;
        }
    }

    deleteAtIndex(index: number): void {
        if (index === 0 && this.head) {
            this.head = this.head.next;
            this.size--;
            return;
        }

        let node = this.getNode(index - 1);
        if (node && node.next) {
            node.next = node.next.next;
            this.size--;
        }
    }
}
```

## 移除链表元素

[地址](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```ts
function removeElements(head: ListNode | null, val: number): ListNode | null {
    // 设置一个虚拟节点
    let newHeader = new ListNode(0, head);
    let cur = newHeader;
    // 从第二个节点开始
    while (cur.next) {

        // 如果第二个节点等于要移除的元素，那么跳过第二个节点
        if (val === cur.next.val) {
            cur.next = cur.next.next;
            continue;
        }
        cur = cur.next;
    }
    
    return newHeader.next;
};

// 没有虚拟节点
function removeElements(head: ListNode | null, val: number): ListNode | null {
    if (head === null) {
        return head;
    }
    let cur = head;
    while (cur.next) {
        if (val === cur.next.val) {
            cur.next = cur.next.next;
            continue;
        }
        cur = cur.next;
    }
    
    return head.val === val ? head.next : head;
};
```

## 螺旋矩阵 II

[地址](https://leetcode-cn.com/problems/spiral-matrix-ii/)

进一步优化：

```ts
function generateMatrix(n: number): number[][] {
    let arr: number[][] = [...Array.from({ length: n }, () => [])];
    let prev = 0;
    let val = 1; // 初始值
    let next = n - 1;
    while(prev < next) {
        let des = next - prev; // 差值
        // 从左到右，从上到下，从右到左，从下到上
        for (let j = prev; j < next; j++) {
            arr[prev][j] = val;
            arr[j][next] = val + des;
            arr[next][next+prev-j] = val + 2 * des
            arr[next+prev-j][prev] = val + 3 * des;
            val++;
        }
        val += 3 * des;
        prev++;
        next--;
    }

    // 如果prev和next相等了
    if (prev === next) {
        arr[prev][next] = val; 
    }
    return arr;
};
```

最开始写法，可能比较好理解：
```ts
function generateMatrix(n: number): number[][] {
    let arr: number[][] = [...Array.from({ length: n }, () => [])];
    let prev = 0;
    let val = 1; // 初始值
    let next = n - 1;
    while(prev < next) {
        
        // 从左到右
        for (let j = prev; j < next; j++) {
            arr[prev][j] = val++;
        }

        // 从上到下
        for (let j = prev; j < next; j++) {
            arr[j][next] = val++;
        }

        // 从右到左
        for (let j = next; j > prev; j--) {
            arr[next][j] = val++;
        }

        // 从下到上
        for (let j = next; j > prev; j--) {
            arr[j][prev] = val++;
        }

        prev++;
        next--;
    }

    // 如果prev和next相等了
    if (prev === next) {
        arr[prev][next] = val; 
    }
    return arr;
};
```

## 长度最小的子数组

采用了滑动窗口的思想，sum为加和的值，一旦sum超过了target，那么prev就需要移动了，移动的值为sum一直减后小于target的值

```ts
function minSubArrayLen(target: number, nums: number[]): number {
    let sum = 0;
    let minIndexLen = Number.MAX_SAFE_INTEGER; // 先设置了极大值
    let prev = 0; // 前面的位置
    for (let i = 0, len = nums.length; i < len; i++) {
        sum += nums[i];
        while (sum >= target) {
            // 判断哪一个最小
            minIndexLen = Math.min(minIndexLen, i - prev + 1);
            sum -= nums[prev++];
        }
    }
    return minIndexLen === Number.MAX_SAFE_INTEGER ? 0 : minIndexLen;
};
```

## 移除元素

```ts
function removeElement(nums: number[], val: number): number {
    let index = 0;
    while (index < nums.length) {
        if (nums[index] === val) {
            nums.splice(index, 1);
        } else {
            index++;
        }
    }
    return nums.length;
};
```

## 二分查找

```ts
function search(nums: number[], target: number): number {
  // 二分查找，左闭右闭
  let prev = 0;
  let next = nums.length - 1;
  while (prev <= next) {
    let half = Math.floor((prev + next) / 2);
    if (nums[half] > target) {
      next = half - 1;
    } else if (nums[half] < target) {
      prev = half + 1;
    } else {
      return half;
    }
  } 
  return -1;
};
```

## 两数之和

通过hash表得到对应的值

```ts
function twoSum(nums: number[], target: number): number[] {
  let map = new Map();
  for (let i = 0, len = nums.length; i < len; i++) {
     if (map.has(nums[i])) {
         return [map.get(nums[i]), i];
     }
     map.set(target - nums[i], i);
  }
};
```

## 无重复字符的最长子串

```ts
function lengthOfLongestSubstring(s: string): number {
  let max = 0;
  let map = new Map();
  let prevIndex = 0;
  // 循环该字符
  for (let i = 0, len = s.length; i < len; i++) {

      // 判断是否存在该元素，存在的话则向右滑动
      if (map.has(s[i]) && map.get(s[i]) >= prevIndex) {
          prevIndex = map.get(s[i]) + 1;
      }
      max = Math.max(max, i - prevIndex + 1);
      map.set(s[i], i);
  }
  return max;
};
```

## 字符串相加

```ts
function addStrings(num1: string, num2: string): string {
  // 判断哪一个最长，较短的使用0补足
  let len1 = num1.length;
  let len2 = num2.length;
  if (len1 < len2) {
    num1 = num1.padStart(len2, '0');
  } else {
    num2 = num2.padStart(len1, '0');
  }

  // 对数字进行循环，从最后一项开始相加
  let str = '';
  let n = 0; // 过程中如果大于10需要
  for (let i = num1.length - 1; i >= 0; i--) {
      let m = Number(num1[i]) + Number(num2[i]) + n;
      str = m % 10 + str;
      n = Math.floor(m / 10);
  }

  // 如果n还有保留，则需要整体加1
  if (n === 1) {
    str = n + str;
  }
  return str;
};
```