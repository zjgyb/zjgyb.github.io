---
title: 算法打卡3
date: 2022-12-10
categories: 算法
tags:
 - 打卡
 - 算法
---

## 子字符串异或查询
[地址](https://leetcode.cn/problems/substring-xor-queries/description/)

```ts
function substringXorQueries(s: string, queries: number[][]): number[][] {
    const arr: string[] = queries.map(([a, b]) => (b ^ a).toString(2))
    const result: number[][] = []

    for (let j = 0; j < arr.length; j++) {
        const index = s.indexOf(arr[j])
        if (index > -1) {
            result.push([index, arr[j].length + index - 1])
        } else {
            result.push([-1,-1])
        }
    }

    return result
};
```

## 找出数组的串联值
[地址](https://leetcode.cn/problems/find-the-array-concatenation-value/)
```ts
function findTheArrayConcVal(nums: number[]): number {
    let sum = 0
    const len = nums.length
    if (!len) {
        return sum
    }

    while(nums.length) {
        if (nums.length === 1) {
            return sum + nums[0]
        }

        sum += Number.parseInt((nums.shift() ?? 0 ).toString() + (nums.pop() ?? 0).toString())
    }

    return sum
};
```

## 合并两个链表
[地址](https://leetcode.cn/problems/merge-in-between-linked-lists/description/)

```ts
// 注意审题，不是相等，是下标
function mergeInBetween(list1: ListNode | null, a: number, b: number, list2: ListNode | null): ListNode | null {
     let delPrev: ListNode | null = null
    let delNext: ListNode | null = null
    const node = new ListNode(0, list1)
    let cur = node
    let n = 0

    while (cur) {
        if (n === a) {
            delPrev = cur
        }

        if (n === b + 1) {
            delNext = cur.next
            break
        }

        cur = cur.next
        n++
    }

    delPrev.next = list2
    cur = list2
    while(cur.next) {
        cur = cur.next
    }

    cur.next = delNext
    return node.next
};
```

## 交换链表中的节点
[地址](https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/description/)

```ts
// 时间复杂度为O(n)，空间复杂度为O(1)
function swapNodes(head: ListNode | null, k: number): ListNode | null {
    if (!head) {
        return head
    }
    let sum = 0
    let node = head

    // 正数节点
    let fast = head
    while(node) {
        if (sum === k - 1) {
            fast = node
        }
        sum++
        node = node.next
    }

    node = head
    // 倒数节点
    let slow = head
    let n = 0
    while(node) {
        if (n === sum - k) {
            slow = node
            break
        }
        n++
        node = node.next
    }

    n = fast.val
    fast.val = slow.val
    slow.val = n

    return head
};
```

```ts
// 时间复杂度为O(n)，空间复杂度为O(n)
function swapNodes(head: ListNode | null, k: number): ListNode | null {
    if (!head) {
        return head
    }
    const stack: ListNode[] = []
    let node = head
    while(node) {
        stack.push(node)
        node = node.next
    }
    const num = stack[k-1].val
    const end = stack[stack.length - k]

    stack[k - 1].val = end.val
    end.val = num
    return head
}
```

```ts
function swapNodes(head: ListNode | null, k: number): ListNode | null {
    if (!head) {
        return head
    }
    const stack: ListNode[] = []
    let node: ListNode | null = head
    while(node) {
        stack.push(node)
        node = node.next
    }

    // 在中间不需要换
    if (k === stack.length - k + 1) {
        return head
    }

    stack.unshift(new ListNode(0, head))
    let min = k - 1
    let end = stack.length - k - 1
    if (min > end) {
        min = end
        end = k - 1
    }

    const s = stack[min]
    const e = stack[end]

    const n = s.next
    const e2 = e.next

    s.next = s.next?.next ?? null
    e.next = e.next?.next ?? null

    // 相互挨着的情况
    if (end - min === 1) {
        s.next!.next = e
        return stack[0].next
    }

    if (n) {
        n.next = e.next
        e.next = n
    }

    if (e2) {
        e2.next = s.next
        s.next = e2
    }

    return stack[0].next
};
```

## 找出临界点之间的最小和最大距离
[地址](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description/)

```ts
// 时间复杂度为O(n)，空间复杂度为O(1)
function nodesBetweenCriticalPoints(head: ListNode | null): number[] {
    if (!head || !head.next || !head.next.next) {
        return [-1, -1]
    }

    let max = -1
    let min = Infinity
    let minPrev = -1
    let prev = -1
    let end = 0

    while (head.next.next) {
        if (head.next.val > head.val && head.next.val > head.next.next.val || (head.next.val < head.val && head.next.val < head.next.next.val)) {
            if (prev !== -1) {
                max = end - minPrev + 1
                min = Math.min(end - prev + 1, min)
            }

            prev = end + 1
            if (minPrev === -1) {
                minPrev = prev
            }
        }
        end++
        head = head.next
    }

    return [Number.isFinite(min) ? min : -1, max]
};
```

## 螺旋矩阵 IV
[地址](https://leetcode.cn/problems/spiral-matrix-iv/description/)
```ts
// 时间复杂度为O(m * n)，空间复杂度为O(m * n)
function spiralMatrix(m: number, n: number, head: ListNode | null): number[][] {
    const result: number[][] = Array.from({ length: m }, () => [])
    let left = 0
    let right = n - 1
    let top = 0
    let bottom = m - 1
    while (top <= bottom) {
        // 从左到右
        for(let i = left; i <= right; i++) {
            if (result[top][i] !== undefined) {
                break
            }
            result[top][i] = head?.val ?? -1
            head = head?.next
        }

        // 从上到下
        for(let i = top + 1; i <= bottom; i++) {
            if (result[i][right] !== undefined) {
                break
            }
            result[i][right] = head?.val ?? -1
            head = head?.next
        }

        // 从右到左
        for(let i = right - 1; i >= left; i--) {
            if (result[bottom][i] !== undefined) {
                break
            }
            result[bottom][i] = head?.val ?? -1
            head = head?.next
        }

        // 从下到上
        for(let i = bottom - 1; i > top; i--) {
            if (result[i][left] !== undefined) {
                break
            }
            result[i][left] = head?.val ?? -1
            head = head?.next
        }

        if (left < right) {
            left++
            right--
        }
        top++
        bottom--
    }
    return result
};
```

## 从链表中移除节点

[地址](https://leetcode.cn/problems/remove-nodes-from-linked-list/description/)

```ts
// 时间复杂度O(n)、空间复杂度为O(n)
function removeNodes(head: ListNode | null): ListNode | null {
    if (!head) {
        return null
    }

    const arr: number[] = []
    while(head) {
        while(arr.length && head.val > arr[arr.length - 1]) {
            arr.pop()
        }
        arr.push(head.val)
        head = head.next
    }
    if (!arr.length) {
        return null
    }
    const node = new ListNode(arr[0])
    let cur = node
    for(let i = 1; i < arr.length; i++) {
        cur.next = new ListNode(arr[i])
        cur = cur.next
    }
    return node
};
```

```ts
// 递归
// 时间复杂度O(n)，空间复杂度O(n)
function removeNodes(head: ListNode | null): ListNode | null {
    if (!head || !head.next) {
        return head
    }

    let node = removeNodes(head.next)
    if (node && head.val < node.val) {
        return node
    }

    head.next = node

    return head
};
```

## 搜索旋转排序数组

[地址](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

```ts
// 时间复杂度为O(logn)，空间复杂度为O(1)
function search(nums: number[], target: number): number {
    let start = 0
    let end = nums.length - 1

    while(start < end) {
        let mid = Math.floor((start + end) / 2)

        if (nums[mid] === target) {
            return mid
        }

        // 中间的值处于左边递增的情况
        if (nums[mid] > nums[end]) {
            if (nums[mid] > target && nums[start] <= target) {
                end = mid
            } else {
                start = mid + 1
            }
            continue
        }

        if (nums[mid] < target && nums[end] >= target) {
            start = mid + 1
        } else {
            end = mid
        }
    }

    return nums[start] === target ? start : -1
};
```

```ts
function search(nums: number[], target: number): number {
    let start = 0
    let end = nums.length - 1

    while(start < end) {
        let mid = Math.floor((start + end) / 2)

        if (nums[mid] === target) {
            return mid
        }

        if ((nums[mid] > nums[end] && (nums[mid] < target || nums[start] > target)) || (nums[mid] < nums[end] && nums[mid] < target && nums[end] >= target)) {
            start = mid + 1
        } else {
            end = mid
        }
    }

    return nums[start] === target ? start : -1
};
```

## 合并K个升序链表

[地址](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

```ts
// ?时间复杂度O(nm + nlogn)，空间复杂度为O(n)
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    const nums: number[] = []
    for(let i = lists.length - 1; i >=0; i--) {
        let list = lists[i]
        while(list) {
            nums.push(list.val)
            list = list.next
        }
    }
    if (!nums.length) {
        return null
    }
    nums.sort((a, b) => a - b)
    const head = new ListNode(nums[0])
    let node = head
    for(let i = 1; i < nums.length; i++) {
        node.next = new ListNode(nums[i])
        node = node.next
    }
    return head
};
```

```ts
// 参考下面的两两合并
// ?时间复杂度为O(n(m+n))，空间复杂度为O(m+n)
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    if (!lists.length) {
        return null
    }

    let result = lists[0]
    for(let i = 1; i < lists.length; i++) {
        result = mergeTwoLists(result, lists[i])
    }
    return result
};
```

## 合并两个有序链表

[地址](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

```ts
// 迭代
// 时间复杂度O(m+n)，空间复杂度为O(1)
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    if (!list1) {
        return list2
    }

    if (!list2) {
        return list1
    }

    const result = new ListNode(-100, list1)
    let node = result

    while (node.next && list2) {
        if (node.next.val <= list2.val) {
            node = node.next
            continue
        }
        node.next = new ListNode(list2.val, node.next)
        list2 = list2.next
        node = node.next
    }

    if (!node.next) {
        node.next = list2
    }

    return result.next
};
```

```ts
// 递归
// 时间复杂度为O(m+n)，空间复杂度为O(m+n)
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    if (!list1) {
        return list2
    }

    if (!list2) {
        return list1
    }

    if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    }

    list2.next = mergeTwoLists(list1, list2.next)
    return list2
};
```

## 删除链表的中间节点
[地址](https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/description/)

```ts
// 快慢指针，时间复杂度为O(n)、空间复杂度为O(1)
function deleteMiddle(head: ListNode | null): ListNode | null {
    if (!head || !head.next) {
        return null
    }

    let slow: ListNode | null = head
    let fast = head.next.next
    while(fast?.next) {
        slow = slow?.next ?? null
        fast = fast.next.next
    }
    if (slow?.next) {
        slow.next = slow.next.next
    }
    return head
};
```

## 回文链表
[地址](https://leetcode.cn/problems/palindrome-linked-list/description/)

```ts
// 时间复杂度为O(n)，空间复杂度为O(n)
function isPalindrome(head: ListNode | null): boolean {
    // 也可以使用字符串
    const arr: number[] = []
    while(head) {
        arr.push(head.val)
        head = head.next
    }

    for (let i = 0, j = arr.length - 1; i < j; i++, j--) {
        if (arr[i] !== arr[j]) {
            return false
        }
    }

    return true
};
```

```ts
// 递归写法
// 时间复杂度 时间复杂度为O(n) 空间复杂度O(n)
function isPalindrome(head: ListNode | null): boolean {
    let prev = head
    const cascader = (cur: ListNode | null) => {
        if (!cur) {
            return true
        }

        let bool = cascader(cur.next)
        if (!bool) {
            return false
        } else if (prev.val !== cur.val) {
            return false
        }

        prev = prev.next
        return true
    }

    return cascader(head)
};
```

```ts
// 时间复杂度为O(n), 空间复杂度为O(1)
// 先获取中间位置的节点，然后反转右半部分的节点，然后进行对比
function isPalindrome(head: ListNode | null): boolean {
   if (!head || !head.next) {
       return true
   }
   const getMid = (head: ListNode | null) => {
       let slow = head
       let fast = head.next

       while (fast) {
           fast = fast.next?.next
           slow = slow.next
       }

       return slow
   }
   const reverse = (head: ListNode | null) => {
       let prev = null
       let cur = head
       while(cur) {
           let next = cur.next
           cur.next = prev
           prev = cur
           cur = next
       }
       return prev
   }
   let prev = getMid(head)
   let next = reverse(prev)

   while(head && next) {
       if (head.val !== next.val) {
           return false
       }
       head = head.next
       next = next.next
   }

   return true
};
```

## 对链表进行插入排序
[地址](https://leetcode.cn/problems/insertion-sort-list/description/)
```ts
// 时间复杂度O(n^2) 空间复杂度O(1)
function insertionSortList(head: ListNode | null): ListNode | null {
    if (!head) {
        return head
    }

    let node = new ListNode(head.val)
    head = head.next
    while (head) {
        let cur: ListNode | null = node
        while (cur.next && cur.next.val < head.val) {
            cur = cur.next
        }

        if (cur.val > head.val) {
            node = new ListNode(head.val, node)
        } else {
            cur.next = new ListNode(head.val, cur.next)
        }

        head = head.next
    }

    return node
};
```

```ts
// 时间复杂度O(n^2) 空间复杂度O(1)
function insertionSortList(head: ListNode | null): ListNode | null {
    if (!head) {
        return head
    }

    // 空节点
    let node = new ListNode(0, head)

    // 排序后链表的最后一个节点
    let lastNode: ListNode | null = head

    // 未排序的第一个节点
    let cur = head.next
    while(cur) {
        if (lastNode!.val <= cur.val) {
            lastNode = lastNode!.next
        } else {

            // 找到需要排序前的一个节点，然后改变指针指向
            let prev = node
            while(prev && prev.next!.val < cur.val) {
                prev = prev.next!
            }
            lastNode!.next = cur.next
            cur.next = prev.next
            prev.next = cur
        }

        cur = lastNode!.next
    }

    return node.next
};
```

## 排序链表
[地址](https://leetcode.cn/problems/sort-list/description/)
```ts
// 时间复杂度为O(nlogn)，空间复杂度为O(n)
function sortList(head: ListNode | null): ListNode | null {
    const arr: number[] = []
    while(head) {
        arr.push(head.val)
        head = head.next
    }
    arr.sort((a, b) => a - b)
    let node = new ListNode(0)
    let cur = node
    for (const val of arr) {
        cur.next = new ListNode(val)
        cur = cur.next
    }
    return node.next
};
```

## 链表组件
[地址](https://leetcode.cn/problems/linked-list-components/description/)
```ts
// 时间复杂度为O(n)，空间复杂度为O(m)
function numComponents(head: ListNode | null, nums: number[]): number {
    const set = new Set(nums)
    let cur = head
    let result = 0
    let num = 0

    while(cur) {
        if (set.has(cur.val)) {
            if (num === 0) {
                result++
            }
            num++
        } else {
            num = 0
        }
        cur = cur.next
    }

    return result
};
```

```ts
// 参考官方解法，把num改成一个boolean
function numComponents(head: ListNode | null, nums: number[]): number {
    const set = new Set(nums)
    let cur = head
    let result = 0
    let isFirst = true

    while(cur) {
        if (set.has(cur.val)) {
            if (isFirst) {
                result++
                isFirst = false
            }
        } else {
            isFirst = true
        }
        cur = cur.next
    }

    return result
}
```

## 分隔链表
[地址](https://leetcode.cn/problems/split-linked-list-in-parts/description/)

```ts
// 时间复杂度O(n)、空间复杂度O(n)
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let sum = 0
    let cur = head
    let arr: (ListNode | null)[] = []

    while(cur) {
        cur = cur.next
        sum++
    }

    cur = head
    let n = Math.ceil(sum / k)
    sum -= n
    k--

    while(cur) {
        if (n === 1) {
            n = Math.ceil(sum / k)
            sum -= n
            k--
            let next = cur.next
            cur.next = null
            arr.push(head)
            head = next
            cur = next
            continue
        }

        cur = cur.next
        n--
    }

    for (let i = 0; i <= k; i++) {
        arr.push(null)
    }

    return arr
};
```

```ts
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let cur = head
    let sum = 0
    let arr: (ListNode | null)[] = []

    while(cur) {
        sum++
        cur = cur.next
    }

    cur = head
    let m = 0
    for (let i = k; i > 0; i--) {
        m = Math.ceil(sum / i)
        sum -= m
        if (m === 0) {
            arr.push(null)
            continue
        }

        while(m > 1) {
            cur = cur.next
            m--
        }
        let next = cur.next
        cur.next = null
        arr.push(head)
        head = next
        cur = next
    }
    return arr
};
```

```ts
// 递归解法
// 时间复杂度O(n)、空间复杂度O(n)
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let cur = head
    let sum = 0
    let arr: (ListNode | null)[] = []

    while(cur) {
        sum++
        cur = cur.next
    }

    for (let i = k; i > sum; i--) {
        arr.push(null)
        k--
    }

    let n = Math.floor(sum / k)
    sum -= n
    k--
    const cascader = (head: ListNode | null) => {
        if (!head) {
            return head
        }
        const node = cascader(head.next)
        n--

        if (n === -1) {
            n = Math.floor(sum / k)
            k--
            sum -= n
            arr.unshift(node)
            head.next = null
            n--
            return head
        }

        return head
    }

   cascader(head)
   if (head) {
       arr.unshift(head)
   }
   return arr
};
```

## 数组中字符串的最大值

[地址](https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/)

```ts
function maximumValue(strs: string[]): number {
    // 使用正则判断是否存在字符串
    const reg = /[a-z]/
    let num = 0
    for (const str of strs) {
        num = Math.max(num, reg.test(str) ? str.length : Number.parseInt(str))
    }

    return num
};
```

## 更多

- [算法打卡1](https://zjgyb.github.io/views/algorithm/2021-5-30.html)
- [算法打卡2](https://zjgyb.github.io/views/algorithm/2021-04-08.html)
