---
title: 算法打卡3
date: 2022-12-10
categories: 算法
tags:
 - 打卡
 - 算法
---

## 搜索旋转排序数组

[地址](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

```ts
// 时间复杂度为O(logn)，空间复杂度为O(1)
function search(nums: number[], target: number): number {
    let start = 0
    let end = nums.length - 1

    while(start < end) {
        let mid = Math.floor((start + end) / 2)

        if (nums[mid] === target) {
            return mid
        }

        // 中间的值处于左边递增的情况
        if (nums[mid] > nums[end]) {
            if (nums[mid] > target && nums[start] <= target) {
                end = mid
            } else {
                start = mid + 1
            }
            continue
        }

        if (nums[mid] < target && nums[end] >= target) {
            start = mid + 1
        } else {
            end = mid
        }
    }

    return nums[start] === target ? start : -1
};
```

```ts
function search(nums: number[], target: number): number {
    let start = 0
    let end = nums.length - 1

    while(start < end) {
        let mid = Math.floor((start + end) / 2)

        if (nums[mid] === target) {
            return mid
        }

        if ((nums[mid] > nums[end] && (nums[mid] < target || nums[start] > target)) || (nums[mid] < nums[end] && nums[mid] < target && nums[end] >= target)) {
            start = mid + 1
        } else {
            end = mid
        }
    }

    return nums[start] === target ? start : -1
};
```

## 合并K个升序链表

[地址](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

```ts
// ?时间复杂度O(nm + nlogn)，空间复杂度为O(n)
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    const nums: number[] = []
    for(let i = lists.length - 1; i >=0; i--) {
        let list = lists[i]
        while(list) {
            nums.push(list.val)
            list = list.next
        }
    }
    if (!nums.length) {
        return null
    }
    nums.sort((a, b) => a - b)
    const head = new ListNode(nums[0])
    let node = head
    for(let i = 1; i < nums.length; i++) {
        node.next = new ListNode(nums[i])
        node = node.next
    }
    return head
};
```

```ts
// 参考下面的两两合并
// ?时间复杂度为O(n(m+n))，空间复杂度为O(m+n)
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    if (!lists.length) {
        return null
    }

    let result = lists[0]
    for(let i = 1; i < lists.length; i++) {
        result = mergeTwoLists(result, lists[i])
    }
    return result
};
```

## 合并两个有序链表

[地址](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

```ts
// 迭代
// 时间复杂度O(m+n)，空间复杂度为O(1)
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    if (!list1) {
        return list2
    }

    if (!list2) {
        return list1
    }

    const result = new ListNode(-100, list1)
    let node = result

    while (node.next && list2) {
        if (node.next.val <= list2.val) {
            node = node.next
            continue
        }
        node.next = new ListNode(list2.val, node.next)
        list2 = list2.next
        node = node.next
    }

    if (!node.next) {
        node.next = list2
    }

    return result.next
};
```

```ts
// 递归
// 时间复杂度为O(m+n)，空间复杂度为O(m+n)
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    if (!list1) {
        return list2
    }

    if (!list2) {
        return list1
    }

    if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    }

    list2.next = mergeTwoLists(list1, list2.next)
    return list2
};
```

## 删除链表的中间节点
[地址](https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/description/)

```ts
// 快慢指针，时间复杂度为O(n)、空间复杂度为O(1)
function deleteMiddle(head: ListNode | null): ListNode | null {
    if (!head || !head.next) {
        return null
    }

    let slow: ListNode | null = head
    let fast = head.next.next
    while(fast?.next) {
        slow = slow?.next ?? null
        fast = fast.next.next
    }
    if (slow?.next) {
        slow.next = slow.next.next
    }
    return head
};
```

## 回文链表
[地址](https://leetcode.cn/problems/palindrome-linked-list/description/)

```ts
// 时间复杂度为O(n)，空间复杂度为O(n)
function isPalindrome(head: ListNode | null): boolean {
    // 也可以使用字符串
    const arr: number[] = []
    while(head) {
        arr.push(head.val)
        head = head.next
    }

    for (let i = 0, j = arr.length - 1; i < j; i++, j--) {
        if (arr[i] !== arr[j]) {
            return false
        }
    }

    return true
};
```

```ts
// 递归写法
// 时间复杂度 时间复杂度为O(n) 空间复杂度O(n)
function isPalindrome(head: ListNode | null): boolean {
    let prev = head
    const cascader = (cur: ListNode | null) => {
        if (!cur) {
            return true
        }

        let bool = cascader(cur.next)
        if (!bool) {
            return false
        } else if (prev.val !== cur.val) {
            return false
        }

        prev = prev.next
        return true
    }

    return cascader(head)
};
```

```ts
// 时间复杂度为O(n), 空间复杂度为O(1)
// 先获取中间位置的节点，然后反转右半部分的节点，然后进行对比
function isPalindrome(head: ListNode | null): boolean {
   if (!head || !head.next) {
       return true
   }
   const getMid = (head: ListNode | null) => {
       let slow = head
       let fast = head.next

       while (fast) {
           fast = fast.next?.next
           slow = slow.next
       }

       return slow
   }
   const reverse = (head: ListNode | null) => {
       let prev = null
       let cur = head
       while(cur) {
           let next = cur.next
           cur.next = prev
           prev = cur
           cur = next
       }
       return prev
   }
   let prev = getMid(head)
   let next = reverse(prev)

   while(head && next) {
       if (head.val !== next.val) {
           return false
       }
       head = head.next
       next = next.next
   }

   return true
};
```

## 对链表进行插入排序
[地址](https://leetcode.cn/problems/insertion-sort-list/description/)
```ts
// 时间复杂度O(n^2) 空间复杂度O(1)
function insertionSortList(head: ListNode | null): ListNode | null {
    if (!head) {
        return head
    }

    let node = new ListNode(head.val)
    head = head.next
    while (head) {
        let cur: ListNode | null = node
        while (cur.next && cur.next.val < head.val) {
            cur = cur.next
        }

        if (cur.val > head.val) {
            node = new ListNode(head.val, node)
        } else {
            cur.next = new ListNode(head.val, cur.next)
        }

        head = head.next
    }

    return node
};
```

```ts
// 时间复杂度O(n^2) 空间复杂度O(1)
function insertionSortList(head: ListNode | null): ListNode | null {
    if (!head) {
        return head
    }

    // 空节点
    let node = new ListNode(0, head)

    // 排序后链表的最后一个节点
    let lastNode: ListNode | null = head

    // 未排序的第一个节点
    let cur = head.next
    while(cur) {
        if (lastNode!.val <= cur.val) {
            lastNode = lastNode!.next
        } else {

            // 找到需要排序前的一个节点，然后改变指针指向
            let prev = node
            while(prev && prev.next!.val < cur.val) {
                prev = prev.next!
            }
            lastNode!.next = cur.next
            cur.next = prev.next
            prev.next = cur
        }

        cur = lastNode!.next
    }

    return node.next
};
```

## 排序链表
[地址](https://leetcode.cn/problems/sort-list/description/)
```ts
// 时间复杂度为O(nlogn)，空间复杂度为O(n)
function sortList(head: ListNode | null): ListNode | null {
    const arr: number[] = []
    while(head) {
        arr.push(head.val)
        head = head.next
    }
    arr.sort((a, b) => a - b)
    let node = new ListNode(0)
    let cur = node
    for (const val of arr) {
        cur.next = new ListNode(val)
        cur = cur.next
    }
    return node.next
};
```

## 链表组件
[地址](https://leetcode.cn/problems/linked-list-components/description/)
```ts
// 时间复杂度为O(n)，空间复杂度为O(m)
function numComponents(head: ListNode | null, nums: number[]): number {
    const set = new Set(nums)
    let cur = head
    let result = 0
    let num = 0

    while(cur) {
        if (set.has(cur.val)) {
            if (num === 0) {
                result++
            }
            num++
        } else {
            num = 0
        }
        cur = cur.next
    }

    return result
};
```

```ts
// 参考官方解法，把num改成一个boolean
function numComponents(head: ListNode | null, nums: number[]): number {
    const set = new Set(nums)
    let cur = head
    let result = 0
    let isFirst = true

    while(cur) {
        if (set.has(cur.val)) {
            if (isFirst) {
                result++
                isFirst = false
            }
        } else {
            isFirst = true
        }
        cur = cur.next
    }

    return result
}
```

## 分隔链表
[地址](https://leetcode.cn/problems/split-linked-list-in-parts/description/)

```ts
// 时间复杂度O(n)、空间复杂度O(n)
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let sum = 0
    let cur = head
    let arr: (ListNode | null)[] = []

    while(cur) {
        cur = cur.next
        sum++
    }

    cur = head
    let n = Math.ceil(sum / k)
    sum -= n
    k--

    while(cur) {
        if (n === 1) {
            n = Math.ceil(sum / k)
            sum -= n
            k--
            let next = cur.next
            cur.next = null
            arr.push(head)
            head = next
            cur = next
            continue
        }

        cur = cur.next
        n--
    }

    for (let i = 0; i <= k; i++) {
        arr.push(null)
    }

    return arr
};
```

```ts
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let cur = head
    let sum = 0
    let arr: (ListNode | null)[] = []

    while(cur) {
        sum++
        cur = cur.next
    }

    cur = head
    let m = 0
    for (let i = k; i > 0; i--) {
        m = Math.ceil(sum / i)
        sum -= m
        if (m === 0) {
            arr.push(null)
            continue
        }

        while(m > 1) {
            cur = cur.next
            m--
        }
        let next = cur.next
        cur.next = null
        arr.push(head)
        head = next
        cur = next
    }
    return arr
};
```

```ts
// 递归解法
// 时间复杂度O(n)、空间复杂度O(n)
function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {
    let cur = head
    let sum = 0
    let arr: (ListNode | null)[] = []

    while(cur) {
        sum++
        cur = cur.next
    }

    for (let i = k; i > sum; i--) {
        arr.push(null)
        k--
    }

    let n = Math.floor(sum / k)
    sum -= n
    k--
    const cascader = (head: ListNode | null) => {
        if (!head) {
            return head
        }
        const node = cascader(head.next)
        n--

        if (n === -1) {
            n = Math.floor(sum / k)
            k--
            sum -= n
            arr.unshift(node)
            head.next = null
            n--
            return head
        }

        return head
    }

   cascader(head)
   if (head) {
       arr.unshift(head)
   }
   return arr
};
```

## 数组中字符串的最大值

[地址](https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/)

```ts
function maximumValue(strs: string[]): number {
    // 使用正则判断是否存在字符串
    const reg = /[a-z]/
    let num = 0
    for (const str of strs) {
        num = Math.max(num, reg.test(str) ? str.length : Number.parseInt(str))
    }

    return num
};
```

## 更多

- [算法打卡1](https://zjgyb.github.io/views/algorithm/2021-5-30.html)
- [算法打卡2](https://zjgyb.github.io/views/algorithm/2021-04-08.html)
