---
title: 算法打卡2
date: 2022-04-08
categories: 算法
tags:
 - 打卡
 - 算法
---

## 前言

之前的[算法打卡](https://zjgyb.github.io/views/algorithm/2021-5-30.html)已经快一年了，由于代码行数较多，因此打开缓慢，故决定再新建一个，用于下一周期的算法打卡

## 第 N 个泰波那契数

[地址](https://leetcode.cn/problems/n-th-tribonacci-number/)

```ts
function tribonacci(n: number): number {
    if (n === 0) {
        return 0
    }

    if (n < 3) {
        return 1
    }

    let [dp1, dp2, dp3] = [0, 1, 1]

    for (let i = 3; i <= n; i++) {
        [dp1, dp2, dp3] = [dp2, dp3, dp1 + dp2 + dp3]
    }

    return dp3
};
```

## 【动态规划】获取生成数组中的最大值

[地址](https://leetcode.cn/problems/get-maximum-in-generated-array/)

```ts
function getMaximumGenerated(n: number): number {
    if (n === 0) {
        return 0
    }

    if (n === 1) {
        return 1
    }

    const dp: number[] = [0, 1]
    let max = 1

    for (let i = 2; i <= n; i++) {
        if (i % 2) {
            dp[i] = dp[Math.ceil(i / 2)] + dp[Math.floor(i / 2)]
        } else {
            dp[i] = dp[i / 2]
        }

        max = Math.max(max, dp[i])
    }

    return max
};
```

## 【动态规划】下降路径最小和

[地址](https://leetcode.cn/problems/minimum-falling-path-sum/)

```ts
// 思路是从上一个路径得出下一个路径的最小值
function minFallingPathSum(matrix: number[][]): number {
    const len = matrix.length
    let dp: number[] = matrix[0]

    for (let i = 1; i < len; i++) {
        const newArr: number[] = []
        for (let j = 0; j < len; j++) {
            newArr[j] = matrix[i][j] + Math.min(dp[j-1] ?? Infinity, dp[j], dp[j+1] ?? Infinity)
        }
        dp = [...newArr]
    }

    return Math.min(...dp)
};
```

## 将整数按权重排序

[地址](https://leetcode.cn/problems/sort-integers-by-the-power-value/)

```ts
function getKth(lo: number, hi: number, k: number): number {
    const map = new Map()
    const dp: [number, number][] = []

    // 获取权重
    for (let i = lo; i <= hi; i++) {
        let j = i
        let k = 0
        let mid: number[] = [j]

        while (j !== 1) {
            if (map.has(j)) {
                k += map.get(j)
                break
            }

            j = j % 2 ? (3 * j + 1) : (j / 2)
            k++
            mid.push(j)
        }

        for (let m = 0; m < mid.length; m++) {
            map.set(mid[m], k - m)
        }

        dp[i-lo] = [i, k]
    }

    return dp.sort(([,prev], [,next]) => prev - next)[k - 1][0]
};
```

## 等差数列划分

[地址](https://leetcode.cn/problems/arithmetic-slices/)

```ts
function numberOfArithmeticSlices(nums: number[]): number {
    const len = nums.length
    if (len < 3) {
        return 0
    }

    const dp: number[] = Array(len).fill(-Infinity)
    let result = 0
    dp[1] = nums[1] - nums[0]

    for (let i = 2; i < len; i++) {
        dp[i] = nums[i] - nums[i-1]

        let j = i

        // 往回算出差值
        while (j > 0 && dp[j] === dp[j-1]) {
            result++
            j--
        }
    }

    return result
};
```

优化：

```ts
// 如果有n个连续的等差数列，那么3个以上的连续等差数列有n * (n + 1) / 2
function numberOfArithmeticSlices(nums: number[]): number {
    const len = nums.length
    if (len < 3) {
        return 0
    }

    let dp = nums[1] - nums[0]
    let result = 0
    let t = 0 // 等差数列的个数

    for (let i = 2; i < len; i++) {
        if (nums[i] - nums[i-1] === dp) {
            t++
        } else {
            dp = nums[i] - nums[i-1]
            t = 0
        }

        result += t
    }

    return result
};
```

## 【回溯】公平分发饼干
[地址](https://leetcode.cn/problems/fair-distribution-of-cookies/)

```ts
function distributeCookies(cookies: number[], k: number): number {
    let result = Infinity
    const content: number[] = Array(k).fill(0)

    const cascader = (cur: number[], start = 0) => {
        if (start >= cookies.length) {
            result = Math.min(result, Math.max(...cur))
            return
        }
        for (let i = 0; i < k; i++) {
            cur[i] += cookies[start]
            cascader(cur, start + 1)
            cur[i] -= cookies[start]
        }
    }

    cascader(content)
    return result
};
```

```ts
// 剪枝利用空间换时间
function distributeCookies(cookies: number[], k: number): number {
    let result = Infinity
    const content: number[] = Array(k).fill(0)
    const map = new Map()
    const maxNum = cookies.length - k + 1

    const cascader = (cur: number[], start = 0) => {
        if (start >= cookies.length) {
            result = Math.min(result, Math.max(...cur))
            return
        }
        for (let i = 0; i < k; i++) {
            if (map.get(i) >= maxNum) {
                continue
            }

            cur[i] += cookies[start]
            map.set(i, (map.get(i) || 0) + 1)
            cascader(cur, start + 1)
            cur[i] -= cookies[start]
            map.set(i, map.get(i) - 1)
        }
    }

    cascader(content)
    return result
};
```

## 【动态规划】统计作战单位数
[地址](https://leetcode.cn/problems/count-number-of-teams/)

```ts
function numTeams(rating: number[]): number {
    const len = rating.length
    // dpMax[i][1] 表示连续2个构成统战 dp[i][2] 连续3个构成统战
    const dpMax: number[][] = Array.from({ length: len }, () => [1, 0, 0])
    const dpMin: number[][] = Array.from({ length: len }, () => [1, 0, 0])
    let result = 0

    for (let i = 1; i < len; i++) {
        for (let j = 0; j < i; j++) {
            if (rating[j] < rating[i]) {
                dpMax[i][1] += dpMax[j][0]
                dpMax[i][2] += dpMax[j][1]
            } else if (rating[j] > rating[i]) {
                dpMin[i][1] += dpMin[j][0]
                dpMin[i][2] += dpMin[j][1]
            }
        }
    }

    for (let i = 0; i < len; i++) {
        result += dpMax[i][2] + dpMin[i][2]
    }

    return result
};
```

## 统计全为 1 的正方形子矩阵

[地址](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/)

【动态规划】

```ts
function countSquares(matrix: number[][]): number {
    const n = matrix.length
    const m = matrix[0].length

    // 拿到第一组
    let dp: number[] = matrix[0]
    let result = matrix[0].reduce((prev, next) => prev + next, 0)

    for (let i = 1; i < n; i++) {
        const arr: number[] = []
        for (let j = 0; j < m; j++) {
            if (j === 0) {
                arr.push(matrix[i][j])
                result += matrix[i][j]
                continue
            }

            if (matrix[i][j] && matrix[i][j-1] && matrix[i-1][j] && matrix[i-1][j-1]) {
                // 取到正方形边长的最小值
                const val = Math.min(dp[j], arr[j-1], dp[j-1]) + 1
                result += val
                arr.push(val)
            } else {
                result += matrix[i][j]
                arr.push(matrix[i][j])
            }
        }
        dp = [...arr]
    }

    return result
};
```

优化：

```ts
function countSquares(matrix: number[][]): number {
    const n = matrix.length
    const m = matrix[0].length

    let dp: number[] = matrix[0]
    let result = matrix[0].reduce((prev, next) => prev + next, 0)

    for (let i = 1; i < n; i++) {
        const arr: number[] = []
        for (let j = 0; j < m; j++) {
            // 只要当前值为1，就可以拓展为多个正方形
            if (j > 0 && matrix[i][j]) {
                const val = Math.min(dp[j], arr[j-1], dp[j-1]) + 1
                result += val
                arr[j] = val
            } else {
                result += matrix[i][j]
                arr[j] = matrix[i][j]
            }
        }
        dp = [...arr]
    }

    return result
};
```

## 优美的排列

[地址](https://leetcode.cn/problems/beautiful-arrangement/)

```ts
function countArrangement(n: number): number {
    let result = 0
    const numArr = Array.from({ length: n }, (v, i) => i + 1)
    const set = new Set()

    // 回溯
    const cascader = (numArr: number[], size: number = 1) => {
        if (size === n + 1) {
            result++
            return
        }

        for (const num of numArr) {
            // 满足条件
            if (set.has(num)) {
                continue
            }

            if (size % num && num % size) {
                continue
            }
            set.add(num)
            cascader(numArr, size + 1)
            set.delete(num)
        }
    }

    cascader(numArr)
    return result
};
```

## 字母在字符串中的百分比
[地址](https://leetcode.cn/problems/percentage-of-letter-in-string/)

```ts
function percentageLetter(s: string, letter: string): number {
    let n = 0
    for (const word of s) {
        word === letter && n++
    }

    return Math.floor(n / s.length * 100)
};
```


## 装满石头的背包的最大数量
[地址](https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/)

```ts
function maximumBags(capacity: number[], rocks: number[], additionalRocks: number): number {
    const add: number[] = []
    let fullNum = 0
    for (let i = 0; i < capacity.length; i++) {
        if (capacity[i] === rocks[i]) {
            fullNum++
        } else {
            add.push(capacity[i] - rocks[i])
        }
    }

    // 排序
    add.sort((a, b) => a - b)

    for (let i = 0; i < add.length; i++) {
        if (add[i] > additionalRocks) {
            break
        }
        fullNum++
        additionalRocks -= add[i]
    }

    return fullNum
};
```

## 在长度 2N 的数组中找出重复 N 次的元素
[地址](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/)

```ts
function repeatedNTimes(nums: number[]): number {
    const len = nums.length
    const half = len / 2
    const map = new Map()

    for (const n of nums) {
        if (map.get(n) === half - 1) {
            return n
        }

        map.set(n, (map.get(n) || 0) + 1)
    }
    return 0
};
```

## 不含特殊楼层的最大连续楼层数
[地址](https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/)

```ts
function maxConsecutive(bottom: number, top: number, special: number[]): number {
    special.sort((a, b) => a - b)
    let maxLevel = special[0] - bottom

    for (let i = 1; i < special.length; i++) {
        maxLevel = Math.max(special[i] - special[i-1] - 1, maxLevel)
    }

    maxLevel = Math.max(maxLevel, top - special[special.length - 1])
    return maxLevel
};
```

## 移除字母异位词后的结果数组
[地址](https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/)

```ts
function removeAnagrams(words: string[]): string[] {
    if (words.length <= 1) {
        return words
    }

    let i = 1
    while (i < words.length) {
        if (words[i-1].split('').sort().join('') === words[i].split('').sort().join('')) {
            words.splice(i, 1)
            continue
        }
        i++
    }
    return words
};
```

## 删列造序
[地址](https://leetcode.cn/problems/delete-columns-to-make-sorted/)

```ts
function minDeletionSize(strs: string[]): number {
    let num = 0

    for (let i = 0; i < strs[0].length; i++) {
        for (let j = 1; j < strs.length; j++) {
            if (strs[j][i].charCodeAt(0) < strs[j-1][i].charCodeAt(0)) {
                num++
                break
            }
        }
    }
    return num
};
```


## 序列化和反序列化二叉搜索树
[地址](https://leetcode.cn/problems/serialize-and-deserialize-bst/)

```ts
// 前序遍历
function serialize(root: TreeNode | null): string {
    if (!root) {
        return ''
    }

    let str = ''
    const cascader = (root: TreeNode | null) => {
        if (!root) {
            return str
        }

        str += root.val + ','
        cascader(root.left)
        cascader(root.right)
    }
    cascader(root)
    return str
};

/*
 * Decodes your encoded data to tree.
 */
// 已知前序和中序遍历生成二叉树
function deserialize(data: string): TreeNode | null {
    const numArr = data.split(',').slice(0, -1).map(item => +item)

    const cascader = (numArr: number[], start: number = 0, end: number = numArr.length) => {
        if (start >= end) {
            return null
        }

        const root = new TreeNode(numArr[start])
        const index = numArr.findIndex((num, idx) => {
            if (idx >= start) {
                return num > numArr[start]
            }
        })

        root.left = cascader(numArr, start + 1, index === -1 ? end : index)
        if (index > -1) {
            root.right = cascader(numArr, index, end)
        }
        return root
    }

    return cascader(numArr)
};
```

## 增减字符串匹配
[地址](https://leetcode.cn/problems/di-string-match/)

```ts
// 贪心算法
// 1. 当前值为I，代表当前值小于下一个值
// 2. 当前值为D，代表当前值大于下一个值
function diStringMatch(s: string): number[] {
    const len = s.length
    let max = len
    let min = 0
    const result: number[] = []

    for (let i = 0; i < len; i++) {
        if (s[i] === 'I') {
            result.push(min++)
        } else {
            result.push(max--)
        }
    }
    result.push(min)
    return result
};
```

## 数组中重复的数据
[地址](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)

```ts
function findDuplicates(nums: number[]): number[] {
    const map = {}
    const result: number[] = []
    for (let i = 0; i < nums.length; i++) {
        if (map[nums[i]]) {
            result.push(nums[i])
        }
        map[nums[i]] = 1
    }
    return result
};
```

## 前序遍历构造二叉搜索树
[地址](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

```ts
// 已知前序遍历和中序遍历，构建二叉树
function bstFromPreorder(preorder: number[]): TreeNode | null {
    const cascader = (preorder, start = 0, end = preorder.length) => {
        if (start >= end) {
            return null
        }

        const node = new TreeNode(preorder[start])
        const index = preorder.findIndex((item, index) => {
            if (index > start) {
                return item > preorder[start]
            }
        })

        // 小于根节点的值为左子节点
        node.left = cascader(preorder, start + 1, index === -1 ? end : index)

        // 超过根节点的值为右子节点
        if (index > -1) {
            node.right = cascader(preorder, index, end)
        }
        return node
    }

    return cascader(preorder)
};
```

## 链表最大孪生和
[地址](https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list/)

```ts
// 直接取出数据，然后求和
function pairSum(head: ListNode | null): number {
    const result: number[] = []
    while(head) {
        result.push(head.val)
        head = head.next
    }
    let max = -Infinity
    let start = 0
    let end = result.length - 1
    while (start < end) {
        max = Math.max(max, result[start] + result[end])
        start++
        end--
    }
    return max
};
```

## 最小差值 I
[地址](https://leetcode-cn.com/problems/smallest-range-i/)

```ts
// 得到最大和最小值，然后判断
function smallestRangeI(nums: number[], k: number): number {
    let max = nums[0]
    let min = nums[0]
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i]
        } else if (nums[i] < min) {
            min = nums[i]
        }
    }

    if (min + 2 * k >= max) {
        return 0
    }

    return max - min - 2 * k
};
```

## 按奇偶排序数组
[地址](https://leetcode-cn.com/problems/sort-array-by-parity/)

```ts
// 遍历
function sortArrayByParity(nums: number[]): number[] {
    const result: number[] = []
    for (let i = 0; i < nums.length; i++) {
        (nums[i] % 2) ? result.push(nums[i]) : result.unshift(nums[i])
    }
    return result
};
```

```ts
// 双指针
function sortArrayByParity(nums: number[]): number[] {
    let prev = 0
    let next = nums.length - 1
    while (prev < next) {
        if (nums[prev] % 2 === 0) {
            prev++
            continue
        }

        if (nums[next] % 2) {
            next--
            continue
        }

        let mid = nums[prev]
        nums[prev] = nums[next]
        nums[next] = mid
        prev++
        next--
    }
    return nums
};
```

## 括号生成
[地址](https://leetcode.cn/problems/generate-parentheses/)

```ts
function generateParenthesis(n: number): string[] {
    const arrLen = n * 2
    const isValid = (content: string, n: number) => {
        let stack: string[] = []
        let start = 0
        for (let i = 0; i < content.length; i++) {
            if (content[i] === '(') {
                stack.push(')')
                if (++start > n) {
                    return false
                }
            } else if (stack.length) {
                stack.pop()
            } else {
                return false
            }
        }
        return true
    }
    let result: string[] = ['(']
    let i = 1

    while (i < arrLen) {
        const len = result.length
        for (let i = 0; i < len; i++) {
            const str = result.shift()
            if (isValid(str + '(', n)) {
                result.push(str + '(')
            }

            if (isValid(str +')', n)) {
                result.push(str + ')')
            }
        }
        i++
    }

    return result
};
```

```ts
// 溯源
function generateParenthesis(n: number): string[] {
    const result: string[] = []
    const end = n * 2

    const cancader = (word: string = '', leftNum = 0) => {
        if (word.length === end) {
            // 无缺失
            !leftNum && result.push(word)
            return
        }

        for (const i of '()') {
            if (leftNum > n) {
                continue
            }

            if (i === ')' && leftNum === 0) {
                break
            }
            cancader(word + i, i === '(' ? leftNum + 1 : leftNum - 1)
        }
    }
    cancader()
    return result
};
```


## 二进制间距
[地址](https://leetcode-cn.com/problems/binary-gap/)

```ts
function binaryGap(n: number): number {
    const twoN = n.toString(2)
    let result = 0
    let start = -1

    for (let i = 0; i < twoN.length; i++) {
        if (twoN[i] === '1') {
            if (start !== -1) {
                result = Math.max(i - start, result)
            }
            start = i
        } else if (twoN[i] === '0' && twoN[i-1] === '1') {
            start = i - 1
        }
    }

    return result
};
```

## 分隔数组以得到最大和
[地址](https://leetcode-cn.com/problems/partition-array-for-maximum-sum/)

```ts
// dp[i] = Math.max(dp[i-j] + max * j, dp[i])
function maxSumAfterPartitioning(arr: number[], k: number): number {
    let len = arr.length
    const dp: number[] = Array(len + 1).fill(0)

    for (let i = 1; i <= len; i++) {
        let max = arr[i-1]
        for (let j = 1; j <= k && j <= i; j++) {
            max = Math.max(max, arr[i-j])
            dp[i] = Math.max(dp[i-j] + max * j, dp[i])
        }
    }

    return dp[len]
};
```

## 山羊拉丁文
[地址](https://leetcode-cn.com/problems/goat-latin/)

```ts
function toGoatLatin(sentence: string): string {
    // 1. 存元音字符
    const set = new Set(['a', 'e', 'i', 'o', 'u'])
    // 2. 切割成数组然后再根据规则获取字符串
    return sentence.split(' ').reduce((str, item, index) => {
        if (set.has(item[0].toLowerCase())) {
            str += ' ' + item + 'ma' + 'a'.repeat(index+1)
        } else {
            str += ' ' + item.slice(1) + item[0] + 'ma' + 'a'.repeat(index+1)
        }
        return str
    }, '').slice(1)
};
```

## 两个字符串的删除操作
[地址](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

```ts
// 动态规划
function minDistance(word1: string, word2: string): number {
    const len1 = word1.length
    const len2 = word2.length
    const dp: number[][] = Array.from({ length: len1 + 1 }, () => Array(len2 + 1).fill(0))

    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            if (word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])
            }
        }
    }

    return len1 + len2 - 2 * dp[len1][len2]
};
```

## 最常见的单词
[地址](https://leetcode-cn.com/problems/most-common-word/)

```ts
// 1. 利用正则切割成数组
// 2. 使用set拿到禁用单词哈希表
// 3. 数组循环拿到最多出现次数的单词
function mostCommonWord(paragraph: string, banned: string[]): string {
    const strArr = paragraph.split(/\W+/i)
    const set = banned.reduce((set, word) => {
        set.add(word)
        return set
    }, new Set)
    let max = 0
    let result = ''
    strArr.reduce((map, word) => {
        let low = word.toLocaleLowerCase()
        if (!set.has(low)) {
            let times = (map.get(low) || 0) + 1
            map.set(low, times)

            if (times > max) {
                max = times
                result = low
            }
        }
        return map
    }, new Map)
    return result
};
```

## 迷你语法分析器
[地址](https://leetcode-cn.com/problems/mini-parser/)

```ts
// 案例"[123,[456,[789,-222],555],-852]"
function deserialize(s: string): NestedInteger {
    let stack: NestedInteger[] = []
    let num = ''
    for(let i = 0; i < s.length; i++) {
        if (s[i] === ',') {
            if (s[i-1] === ']') {
                continue
            }

            stack[stack.length - 1].add(new NestedInteger(Number(num)))
            num = ''
            continue
        }

        if (s[i] === ']') {
            if (num) {
                stack[stack.length - 1].add(new NestedInteger(Number(num)))
                num = ''
            }

            stack.length > 1 && stack[stack.length - 2].add(stack.pop())
            continue
        }

        if (s[i] === '[') {
            stack.push(new NestedInteger())
            continue
        }
        num += s[i]
    }

    if (num) {
        return new NestedInteger(Number(num))
    }
    return stack[0]
};
```

## 最富有客户的资产总量
[地址](https://leetcode-cn.com/problems/richest-customer-wealth/)

```ts
function maximumWealth(accounts: number[][]): number {
    let max = 0
    for (const account of accounts) {
        let sum = account.reduce((s, val) => s + val, 0)
        max = Math.max(sum, max)
    }
    return max
};
```

## 单词拆分 II
[地址](https://leetcode-cn.com/problems/word-break-ii/)

```ts
function wordBreak(s: string, wordDict: string[]): string[] {
    const dp: boolean[] = Array(s.length + 1).fill(false)
    dp[0] = true

    for (let i = 1; i <= s.length; i++) {
        for (let word of wordDict) {
            const wLen = word.length
            if (i >= wLen && s.startsWith(word, i - wLen) && dp[i-wLen]) {
                dp[i] = true
            }
        }
    }

    if (!dp[s.length]) {
        return []
    }

    const set = wordDict.reduce((set, w) => {
        set.add(w)
        return set
    }, new Set)

    // 回溯
    const result: string[] = []
    let sArr: string[] = []

    const cascader = (s: string, start: number = 1) => {
        if (start > s.length) {
            result.push(sArr.join(' '))
            return
        }
        let s1 = ''
        for (let i = start; i <= s.length; i++) {
            s1 += s[i-1]
            if (dp[i] && set.has(s1)) {
                sArr.push(s1)
                cascader(s, i + 1)
                sArr.pop()
            }
        }
    }

    cascader(s)
    return result
};
```

## 零钱兑换

[地址](https://leetcode-cn.com/problems/coin-change/)

```ts
// 动归
// dp[j]表示amount时最少的硬币个数
function coinChange(coins: number[], amount: number): number {
  const dp: number[] = Array(amount + 1).fill(Infinity)
    dp[0] = 0

    for (const coin of coins) {
        for (let j = coin; j <= amount; j++) {
            dp[j] = Math.min(dp[j], dp[j-coin] + 1)
        }
    }

    return dp[amount] > Number.MAX_SAFE_INTEGER ? -1 : dp[amount]
};
```